### Calculate the median stellar template for all observations (or except the observation which the RV will be calculated) and the median telluric template, two iterations are implementes, in the second templates are made neglecting telluric zones. To calculate the RV through chi2 minimization the slope of the stellar and telluric template are obtained and selected zones satisfy slope_stellar/slope_telluric > 10, where both templated are scaled to the observad spectrum. A 5 sigma clipping is also implemented. A Voigt and Gauss fit is done to the chi2 values corresponding to each RVi of a the RVs explored domain. For the Gauss fit we use only RVs in 1 plate scale or resolution element of the instrument. The calculated RV correspond to center of the Gauss fit. (Same as extracteur_vitesses_radiales.py + compute the chi2 profile bisector span)

#compared to v5.py, includes support for SOPHIE data, and allows to skip iteration 0 in get_rv(), using previous RV from CCF or table

import argparse
# Create the parser
parser = argparse.ArgumentParser(description='Target name')

# Add the arguments
parser.add_argument('target', type=str, help='the name of the star you want to compute NAIRA')

# Execute the parse_args() method
args = parser.parse_args()

target = args.target

#target = 'HD185144'
savename = target+'_cti'#_2it_w7s10c5'

data_dir = '/net/GSP/users/pcortes/SOPHIE/data_'+target+'/' #Gl205/'

data_dir_tables = '/home/nicola/Desktop/these/data/tables/' # Path to the table containing the trasmittance, it is used to compute the activity indices
trasmittance_file = 'trasmittance_curve_btsettl.dat'
instrument = 'OHP' #valid entries ['ESO','TNG','OHP'] ;ESO => HARPS, TNG => HARPS-N ;OHP => SOPHIE


tmpl_ans = 'y'                                        # Create template [y] or load it [!y] or load it from another target [path+target_template.npz]
opt_tmpl_ans = True                                    # Neglect telluric zones to made the template. Should not be used for poor berv span
skip_bjd_tmpl_ans = False                                # Calculate the template for each analysed data without considering it for the template
wave_ans = False                                      #Load wave solution [True] or generate it [False]
rv_data_ans = ''  # Previous RV to generate the template [file.rdb/n]
rv_avg = False                                        # Generate the template from a single RV value (manual or average from CCF)
rv_avg_val = 99                                           # The template is generated by using this value, if rv_avg_val = 99 it uses average from CCF (check rv_avg = True )
rv_ans = True                                         # Extract RV
rad_vel1_ans = True                                    # Use previous RV (from CCF or table) to estimate rejected zones (telluric and outliers)
stitching = False                                      # Avoid CCD stitiching (see Dumusque+2015)
table_berv = ''         #file path+name of the table with berv
fit_to_R = True                                       #Fit a gaussian around the chi2 distr. minimum using one element resolution [y] or one plate scale
neglect_tellurics_slope = True                              # Discard telluric zones (considering their slope against stellar lines) and outliers
neglect_tellurics_forced = False                              # Discard all detected tellurics
telluric_file = '' #Use specified telluric spectra instead of use its own[path+file.npz/n]
compute_activity_ind = True                       # Calculate the S and Halpha indices
plot_ans_tmpl = False                                      # show plots of the template creation [y/n]
plot_ans_rv = False                                        # show plots of the rv extraction [y/n]
save_ans = True                                       # save template and RV [y/n]


instr_R = 75000.                                     #Instrument resolution.  HARPS(-N)=115000, SOPHIE=75000
plate_scale = 1.4 #km/s
N_proc = 10 
rv_ini, rv_end, rv_step = 99, 99, plate_scale         # if rv_ini, rv_end = 99, 99 we consider  rv_ini, rv_end = rv_average - 13, rv_average + 13 [km/s]


            
from scipy.ndimage.filters import maximum_filter1d
from scipy.interpolate import UnivariateSpline
from matplotlib.pylab import GridSpec
from scipy.optimize import curve_fit
from multiprocessing import Process
from matplotlib import pylab as pl
from scipy.signal import medfilt
from scipy.special import wofz
from scipy.stats import skew
from pyfits import open as openFits

from glob import glob
import scipy as sci
import os


pl.rcParams.update({'font.size': 16})
sci.seterr(divide='ignore', invalid='ignore')


special_bjd = sci.array([])	
#special_bjd = sci.array([])
#special_bjd_interval = sci.array([7172,9999])
special_bjd_interval = sci.array([0,5730])	# ignore observations done pre octogonal fiber installation

neglect_bjd = True  # neglect (True) or select (False) special_bjd

neglect_orders = sci.array([])
#neglect_orders = sci.array([56,57,63,66,67,71])
#neglect_orders = sci.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,29,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71]) #act
#neglect_orders = sci.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,61,62,63,64,65,66,67,70,71]) #no act


c = 299792.458 #light speed km/s
slope_width = 7   # number of points used to compute the slope (default 7)
dopp_slope = 10   # minimum slope_stellar / slope_telluric to compute RVs (default 10)
sig_clip = 5      # sigma clipping value (default 5)

if skip_bjd_tmpl_ans:
    tmpl_ans = 'y'

if plot_ans_rv:
    N_proc = 1


def Gauss(x,depth,x0,width,y0):
    return depth*sci.exp(-0.5*((x-x0)/width)**2)+y0


def Voigt(x,A,mu,al,ad,off):
    """
    A - Amplitude
    mu - Center
    al - Scale parameter of the Cauchy-Lorentz distribution
    ad - The width of the Gaussian distribution
    off - Constant offset
    """

    z = ((x-mu) + (1.j)*al)/(sci.sqrt(2.0) * ad)
    y = A * sci.real(wofz(z)) 
    y /= (ad * sci.sqrt(2.0*sci.pi))
    y += off  
    y[sci.where(sci.isnan(y))] = 0.0

    return y

  
def Voigt_FWHM(al,ad):
    # The width of the Lorentz profile
    fl =  2.0 * al
    # Width of the Gaussian [2.35 = 2*sigma*sqrt(2*ln(2))]
    fd = 2.35482 * ad
    return 0.5346*fl + sci.sqrt(0.2166*(fl**2.) + fd**2.)

######
def correct_cti(spe):
    alpha=0.005        # valeur parametre alpha
    beta=-0.82          # valeur parametre beta
    gamma=0.205        # valeur parametre gamma
    delta=3.           # valeur parametre delta
    backG=50.          # valeur parametre backG

    lenspe=sci.shape(spe)[1]
    
    spec=sci.where(spe<=0,0.0000001,spe)
    var=sci.where(-gamma*(backG/spec)**delta<-745.,-745.,-gamma*(backG/spec)**delta)
    cte=1.-alpha*((spec)**(beta))*sci.exp(var)  
    cte2=sci.power(cte,lenspe-sci.arange(lenspe))
    for w in range(lenspe-1,0,-1):						
        spe[:,w]=spe[:,w]/cte2[:,w]
        spe[:,w-1]=spe[:,w-1]-(spe[:,w]-spe[:,w]*cte2[:,w])
    
    spe[:,0]=spe[:,0]/cte2[:,0]
#####


class Spec:
    def __init__(self,data_dir0,file_list0):
        self.data_dir = data_dir0
        self.file_list = file_list0


    def get_wave(self,fits_file):
        """ Generate wave solution """
        kw_root_drs_th = 'HIERARCH '+instrument+' DRS CAL TH '
        N_order        = fits_file[0].header[kw_root_drs_th+'ORDER NBR']
        Deg_ll         = fits_file[0].header[kw_root_drs_th+'DEG LL']
        Deg_x          = fits_file[0].header[kw_root_drs_th+'DEG X']
        x_size         = fits_file[0].header['NAXIS1']
        y_size         = fits_file[0].header['NAXIS2']

        kw = []
        param_ll = []
        for i in range(N_order):
            for j in range(Deg_ll+1):
                kw.append(kw_root_drs_th+'COEFF LL'+"%d"%(i*(Deg_ll+1)+j))

        for i in range(len(kw)):
            param_ll.append(fits_file[0].header[kw[i]])
        param_ll = sci.reshape(param_ll,(N_order,Deg_ll+1))

        kw = []
        param_x = [] 
        for i in range(N_order):
            for j in range(Deg_x+1):
                kw.append(kw_root_drs_th+'COEFF X'+"%d"%(i*(Deg_x+1)+j))

        for i in range(len(kw)):
            param_x.append(fits_file[0].header[kw[i]])
        param_x = sci.reshape(param_x,(N_order,Deg_x+1))

        x = sci.arange(x_size)*1.0
        x = sci.reshape([x]*N_order,(N_order,x_size))

        ll_std=[]
        for o in range(N_order):
            ll_std_ii=[]
            for i in range(len(param_ll[0])):
                ll_std_ii.append(param_ll[o,i]*x[o,:]**(i))
            ll_std.append(sci.sum(sci.reshape(ll_std_ii,(len(param_ll[0]),x_size)),axis=0))

        ll=sci.reshape(ll_std,(len(ll_std),len(ll_std[0])))
   
        return ll,param_ll,param_x



    def avoid_bjd(self, current_bjd, bjd_val, bjd_interval, neglect_bjd):
        """ Avoid spectra given a bjd interval or matching bjd values (bjd-2450000) """
        avoid_i = False

        if len(bjd_interval) > 0:
            if (round(current_bjd-2450000.,6) > bjd_interval[0]) & (round(current_bjd-2450000.,6) < bjd_interval[1]) and neglect_bjd:
                avoid_i = True

            if (round(current_bjd-2450000.,6) < bjd_interval[0]) | (round(current_bjd-2450000.,6) > bjd_interval[1]) and not neglect_bjd:
                avoid_i = True


        if len(bjd_val) > 0:
            if not neglect_bjd:
                avoid_i = True

            for bjd_val_i in bjd_val:
                if round(bjd_val_i,6) == round(current_bjd-2450000,6) and neglect_bjd:
                    avoid_i = True
                    break

                if round(bjd_val_i,6) == round(current_bjd-2450000,6) and not neglect_bjd:
                    avoid_i = False
                    break

        return avoid_i



    def load_spec(self,tmpl_ans,rv_data_ans,special_bjd,special_bjd_interval,neglect_bjd, rv_avg, rv_avg_val):
        """ Load spectra and all parameters """
        self.Flux, self.Wavelength, self.Blaze, self.Bjd, self.Berv, self.Rvc, self.readout_noise, self.SN10, self.SN50, self.SN60, self.Airmass, self.Seeing, self.Contrast, self.FWHM, self.Bis_span, self.root_file, file_i = [], [], [], sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), 0
        read_file1, read_file2 = True, True

        while file_i < len(self.file_list):
            fits_file = openFits(self.file_list[file_i])
            # Wavelength solutions from Fabry-Perot have *e2ds_A.fits extension (like science files)
            try:
                if instrument == 'ESO':
                    if fits_file[0].header['OBJECT']  == 'WAVE,WAVE,FP' or fits_file[0].header['OBJECT'] == 'WAVE,WAVE,THAR2':
                        self.file_list.remove(self.file_list[file_i])
                        continue

                if instrument == 'TNG':
                    if fits_file[0].header['OBS-TYPE']  != 'SCIENCE':
                        print self.file_list[file_i],'is not a SCIENCE file'
                        self.file_list.remove(self.file_list[file_i])
                        continue
            except:
                print ' * Check observation type or instrument entry'
                pass

            root_file_aux = self.file_list[file_i][:(self.file_list[file_i]).find('_e2ds_A.fits')]
            self.root_file = sci.append(self.root_file, root_file_aux)

            current_bjd = fits_file[0].header['HIERARCH '+instrument+' DRS BJD']

            if len(special_bjd) > 0 or len(special_bjd_interval) > 0:
                if self.avoid_bjd(current_bjd,special_bjd,special_bjd_interval,neglect_bjd):
                    self.file_list.remove(self.file_list[file_i])
                    continue

                
            if rv_data_ans.find('.rdb') != -1:
                try:
                    if read_file1:
                        rvc_file = sci.loadtxt(rv_data_ans,skiprows=2,usecols=(0,1))
                        read_file1 = False
                        
                    pos_rv = sci.where(rvc_file[:,0] == round(current_bjd-2400000.,6))[0]

                    if len(pos_rv) == 0:
                        try:
                            rvc_val = openFits(glob(root_file_aux+'_ccf_*_A.fits')[0])[0].header['HIERARCH '+instrument+' DRS CCF RVC']
                        except:
                            rvc_val = openFits((glob(root_file_aux+'_ccf_*_A.fits')[0]).replace(':','_',2))[0].header['HIERARCH '+instrument+' DRS CCF RVC']

                        print ' * RV not found for bjd '+str(round(current_bjd-2400000.,6))+'. Using RV from mask CCF'

                    else:
                        rvc_val = float(rvc_file[pos_rv,1])
                        rvc_file = sci.delete(rvc_file, pos_rv, axis=0)


                except:
                    print ' * RV file not found. Using RV from mask CCF'
                    rv_data_ans = ''


            if rv_data_ans.find('.rdb') == -1 and not rv_avg:
                if instrument == 'ESO' or instrument == 'TNG':
                    rv_header_key = 'HIERARCH '+instrument+' DRS CCF RVC'

                if instrument == 'OHP':
                    rv_header_key = 'HIERARCH '+instrument+' DRS CCF RV'

                try:
                    try:
                        rvc_val = openFits(glob(root_file_aux+'_ccf_*_A.fits')[0])[0].header[rv_header_key]
                    except:
                        rvc_val = openFits((glob(root_file_aux+'_ccf_*_A.fits')[0]).replace(':','_',2))[0].header[rv_header_key]

                except:
                    print ' * CCF file not found for e2ds file',self.file_list[file_i]
                    self.file_list.remove(self.file_list[file_i])
                    continue


            wavelength_file_name = fits_file[0].header['HIERARCH '+instrument+' DRS CAL TH FILE']
            if wavelength_file_name.find('e2ds') != -1:
                wavelength_file_name = wavelength_file_name[:-12]+'_wave_A.fits'

            if wave_ans:
                try:
                    wave_solution = openFits(data_dir+wavelength_file_name)[0].data
                except:
                    try:
                        wave_solution = openFits(data_dir+wavelength_file_name.replace(':','_',2))[0].data
                    except:
                        print ' * Wavelength solution file',wavelength_file_name,'not found for spectrum',self.file_list[file_i][len(self.data_dir):]
                        #wave_solution = self.get_wave(fits_file)[0]
                        self.file_list.remove(self.file_list[file_i])
                        continue

            else:
                wave_solution = self.get_wave(fits_file)[0]
                

            if instrument == 'ESO':
                blaze_file_name = fits_file[0].header['HIERARCH '+instrument+' DRS BLAZE FILE']
                
            if instrument == 'TNG':
                blaze_file_name = fits_file[0].header['HIERARCH '+instrument+' DRS BLAZE FILE']

            if instrument == 'OHP':
                blaze_file_name = fits_file[0].header['HIERARCH '+instrument+' DRS CAL FLAT FILE'].replace('flat','blaze')

            ##### param for LHS1723
            #if round(current_bjd,6) == round(2456995.81626919,6) or round(current_bjd,6) == round(2456996.79907095,6):
            #    blaze_file_name = 'HARPS.2014-12-03T19:26:25.106_blaze_A.fits'
            #####
            try:
                self.Blaze.append(openFits(data_dir+blaze_file_name)[0].data)
            except:
                try:
                    self.Blaze.append(openFits(data_dir+blaze_file_name.replace(':','_',2))[0].data)
                except:
                    print ' * Missed blaze file',blaze_file_name,'for spectrum',self.file_list[file_i][len(self.data_dir):]
                    self.file_list.remove(self.file_list[file_i])
                    continue
                
            correct_cti(fits_file[0].data)
            self.Flux.append(fits_file[0].data)
            self.Wavelength.append(wave_solution)
            if not rv_avg:
                self.Rvc = sci.append(self.Rvc,rvc_val)


            self.Bjd, self.readout_noise = sci.append(self.Bjd,current_bjd), sci.append(self.readout_noise,sci.sqrt(6.)*float(fits_file[0].header['HIERARCH '+instrument+' DRS CCD SIGDET'])/float(fits_file[0].header['HIERARCH '+instrument+' DRS CCD CONAD']))


            if table_berv.find('rdb') == -1:
                self.Berv = sci.append(self.Berv,fits_file[0].header['HIERARCH '+instrument+' DRS BERV'])
            else:
                if read_file2:
                    berv_file = sci.loadtxt(table_berv,skiprows=2)
                    read_file2 = False

                pos_berv = sci.where(berv_file[:,0] == round(current_bjd,6))[0]

                if len(pos_berv) > 0:
                    berv_val = float(berv_file[pos_berv,1])
                    self.Berv = sci.append(self.Berv, berv_val)
                    berv_file = sci.delete(berv_file, pos_berv, axis=0)
                else:
                    print ' ### Berv not found. Using from header'
                    self.Berv = sci.append(self.Berv,fits_file[0].header['HIERARCH '+instrument+' DRS BERV'])


            if instrument == 'ESO':
                self.SN10, self.SN50, self.SN60 = sci.append(self.SN10,fits_file[0].header['HIERARCH '+instrument+' DRS SPE EXT SN10']), sci.append(self.SN50,fits_file[0].header['HIERARCH '+instrument+' DRS SPE EXT SN50']), sci.append(self.SN60,fits_file[0].header['HIERARCH '+instrument+' DRS SPE EXT SN60'])
                
                self.Airmass = sci.append(self.Airmass,round((fits_file[0].header['HIERARCH '+instrument+' TEL AIRM START']+fits_file[0].header['HIERARCH '+instrument+' TEL AIRM END'])/2.,2))
                
                self.Seeing = sci.append(self.Seeing, round((fits_file[0].header['HIERARCH '+instrument+' TEL AMBI FWHM START']+fits_file[0].header['HIERARCH '+instrument+' TEL AMBI FWHM END'])/2.,2))
                

            if instrument == 'TNG':
                self.SN10, self.SN50, self.SN60 = sci.append(self.SN10,fits_file[0].header['HIERARCH '+instrument+' DRS SPE EXT SN10']), sci.append(self.SN50,fits_file[0].header['HIERARCH '+instrument+' DRS SPE EXT SN50']), sci.append(self.SN60,fits_file[0].header['HIERARCH '+instrument+' DRS SPE EXT SN60'])
                
                self.Airmass = sci.append(self.Airmass,fits_file[0].header['AIRMASS'])
                
                self.Seeing = sci.append(self.Seeing, 99)


            if instrument == 'OHP':
                self.SN10, self.SN50, self.SN60 = sci.append(self.SN10,fits_file[0].header['HIERARCH '+instrument+' DRS CAL EXT SN4']), sci.append(self.SN50,fits_file[0].header['HIERARCH '+instrument+' DRS CAL EXT SN27']), sci.append(self.SN60,fits_file[0].header['HIERARCH '+instrument+' DRS CAL EXT SN32'])
                
                self.Airmass = sci.append(self.Airmass,round((fits_file[0].header['HIERARCH '+instrument+' TEL AIRM START']+fits_file[0].header['HIERARCH '+instrument+' TEL AIRM END'])/2.,2))
                
                self.Seeing = sci.append(self.Seeing, fits_file[0].header['HIERARCH '+instrument+' GUID SEEING'])

            # Close main fits file
            fits_file.close()

            if instrument != 'OHP':           		
                try:
                    try:
                        hdr = openFits(glob(root_file_aux+'_bis_*_A.fits')[0])[0].header
                        self.Contrast, self.FWHM, self.Bis_span = sci.append(self.Contrast,hdr['HIERARCH '+instrument+' DRS CCF CONTRAST']), sci.append(self.FWHM,hdr['HIERARCH '+instrument+' DRS CCF FWHM']), sci.append(self.Bis_span,hdr['HIERARCH '+instrument+' DRS BIS SPAN'])
                    except:
                        hdr = openFits((glob(root_file_aux+'_bis_*_A.fits')[0]).replace(':','_',2))[0].header
                        self.Contrast, self.FWHM, self.Bis_span = sci.append(self.Contrast,hdr['HIERARCH '+instrument+' DRS CCF CONTRAST']), sci.append(self.FWHM,hdr['HIERARCH '+instrument+' DRS CCF FWHM']), sci.append(self.Bis_span,hdr['HIERARCH '+instrument+' DRS BIS SPAN'])
                        hdr.close()

                except:
                    print ' * Bis file not found for root file',self.file_list[file_i][-42:-12]	#root from harps was -41:-12
                    self.Contrast, self.FWHM, self.Bis_span = sci.append(self.Contrast,99), sci.append(self.FWHM,99), sci.append(self.Bis_span,99)

            elif instrument == 'OHP':            		
                try:
                    try:
                        hdr = openFits(glob(root_file_aux+'_ccf_*_A.fits')[0])[0].header
                        self.Contrast, self.FWHM, self.Bis_span = sci.append(self.Contrast,hdr['HIERARCH '+instrument+' DRS CCF CONTRAST']), sci.append(self.FWHM,hdr['HIERARCH '+instrument+' DRS CCF FWHM']), sci.append(self.Bis_span,hdr['HIERARCH '+instrument+' DRS CCF SPAN'])
		        #hdr.close()
#                    except Exception as e: print str(e)
                    except:
                        hdr = openFits((glob(root_file_aux+'_ccf_*_A.fits')[0]).replace(':','_',2))[0].header
                        self.Contrast, self.FWHM, self.Bis_span = sci.append(self.Contrast,hdr['HIERARCH '+instrument+' DRS CCF CONTRAST']), sci.append(self.FWHM,hdr['HIERARCH '+instrument+' DRS CCF FWHM']), sci.append(self.Bis_span,hdr['HIERARCH '+instrument+' DRS CCF SPAN'])
 #                       hdr.close()
                except:
                    print ' * ccf header data not found for root file',self.file_list[file_i][-42:-12]	#root from harps was -41:-12
                    self.Contrast, self.FWHM, self.Bis_span = sci.append(self.Contrast,99), sci.append(self.FWHM,99), sci.append(self.Bis_span,99)


            if file_i == 0:
                self.N_order, self.N_pix = len(self.Flux[0]),len(self.Flux[0][0])

            #Increasing while
            file_i+=1


        self.N_spectra =  len(self.file_list)

        # Add the option to use a single value (average rv_ccf or manual) of RV
        if rv_avg:
            if rv_avg_val == 99:
                self.Rvc = sci.zeros(self.N_spectra) + sci.average(self.Rvc)
            else:
                self.Rvc = sci.zeros(self.N_spectra) + rv_avg_val


    def flux(self,spec_i,order_i):
        """ Return  the flux for a given order and spectra """
        return self.Flux[spec_i][order_i].astype(sci.float64)

    def wave(self,spec_i,order_i):
        """ Return  the wavelength solution for a given order and spectra """
        return self.Wavelength[spec_i][order_i].astype(sci.float64)

    def wave_restFrame(self,spec_i,order_i):
        """ Shift the wavelength solution to the rest frame for a given order and spectra """
        return self.wave(spec_i,order_i)*(1.+self.berv(spec_i)/c)/(1.+self.vrad(spec_i)/c)

    def wave_starFrame(self,wave,spec_i):
        """ Shift the wavelength solution to the star frame for a given order and spectra """
        return wave*(1.+self.vrad(spec_i)/c)/(1.+self.berv(spec_i)/c)

    def blaze(self,spec_i,order_i):
        """ Return the blaze function for a given order and spectra """
        return self.Blaze[spec_i][order_i].astype(sci.float64)

    def subBlaze(self,spec_i,order_i,used_pix=sci.array([])):
        """ Subtract the blaze function for a given order and spectra and normalize """
        if len(used_pix) == 0:
            return self.flux(spec_i,order_i)*sci.median(self.blaze(spec_i,order_i))/self.blaze(spec_i,order_i)/sci.median(maximum_filter1d(self.flux(spec_i,order_i),200))
            #nocosmic = self.no_cosmic(self.flux(spec_i,order_i))
            #return self.flux(spec_i,order_i)*sci.median(self.blaze(spec_i,order_i))/self.blaze(spec_i,order_i)/sci.median(maximum_filter1d(self.flux(spec_i,order_i)[nocosmic],200))

        else:
            return self.flux(spec_i,order_i)*sci.median(self.blaze(spec_i,order_i)[used_pix])/self.blaze(spec_i,order_i)/sci.median(maximum_filter1d(self.flux(spec_i,order_i)[used_pix],200))
            #nocosmic = self.no_cosmic(self.flux(spec_i,order_i)[used_pix])
            #return self.flux(spec_i,order_i)*sci.median(self.blaze(spec_i,order_i)[used_pix])/self.blaze(spec_i,order_i)/sci.median(maximum_filter1d(self.flux(spec_i,order_i)[used_pix][nocosmic],200))


    def addBlaze(self,noBlaze,spec_i,order_i,used_pix=sci.array([])):
        """ Add the blaze function and scale to a given order and spectra """
        if len(used_pix) == 0:
            return noBlaze*self.blaze(spec_i,order_i)*sci.median(maximum_filter1d(self.flux(spec_i,order_i),200))/sci.median(self.blaze(spec_i,order_i))
            #nocosmic = self.no_cosmic(self.flux(spec_i,order_i))
            #return noBlaze*self.blaze(spec_i,order_i)*sci.median(maximum_filter1d(self.flux(spec_i,order_i)[nocosmic],200))/sci.median(self.blaze(spec_i,order_i))
        else:
            return noBlaze*self.blaze(spec_i,order_i)*sci.median(maximum_filter1d(self.flux(spec_i,order_i)[used_pix],200))/sci.median(self.blaze(spec_i,order_i)[used_pix])
            #nocosmic = self.no_cosmic(self.flux(spec_i,order_i)[used_pix])
            #return noBlaze*self.blaze(spec_i,order_i)*sci.median(maximum_filter1d(self.flux(spec_i,order_i)[used_pix][nocosmic],200))/sci.median(self.blaze(spec_i,order_i)[used_pix])

    def re_norm(self,wave,flux,size,trim=0):
        """ Re-normalize a given order to ensure the flatness in the continua"""
        if trim == 0:
            flux_M = maximum_filter1d(flux, size)
            a, b = sci.polyfit(wave, flux_M, 1)
        else:
            flux_M = maximum_filter1d(flux[trim:-trim], size)
            a, b = sci.polyfit(wave[trim:-trim], flux_M, 1)
        return flux/(a*wave+b)

    #def no_cosmic(self,e2ds):
    #    """ Clean for cosmics by rejecting pixels above 1.5 times the signal at the center 
    #    of the order in e2ds """
    #    center_a = int(self.n_pix()/2.-400)
    #    center_b = int(self.n_pix()/2.+401)
    #    threshold = 1.5*sci.median(maximum_filter1d(e2ds[center_a:center_b],50))
    #    pos_cosmic = sci.where(e2ds > threshold)[0]
    #    pos_cosmic = add_elements(pos_cosmic,3,0,len(e2ds))
    #    return sci.delete(sci.arange(len(e2ds),dtype='int'),pos_cosmic)
        
    def bjd(self,spec_i):
        """ Return the barycentric julian date for a given spectra """ 
        return self.Bjd[spec_i].astype(sci.float64)

    def berv(self,spec_i):
        """ Return the barycentric earth radial velocity for a given spectra """ 
        return self.Berv[spec_i].astype(sci.float64)

    def vrad(self,spec_i):
        """ Return the "previous (from ccf or table)" radial velocity for a given spectra """ 
        return self.Rvc[spec_i].astype(sci.float64)

    def vrad_avrg(self):
        """ Return the average radial velocity of the data set """
        return sci.average(self.Rvc)

    def vrad_median(self):
        """ Return the median radial velocity of the data set """
        return sci.median(self.Rvc)

    def argbluer(self):
        """ Return the argument of the spectra which is bluer shifted """
        return ((c+self.Rvc)/(c+self.Berv)).argmax()

    def argredder(self):
        """ Return the argument of the spectra which is reder shifted """
        return ((c+self.Rvc)/(c+self.Berv)).argmin()

    def sigma_readout(self,spec_i):
        """ Return the read-out instrumental noise """
        return self.readout_noise[spec_i].astype(sci.float64)

    def sn10(self,spec_i):
        """ Return the signal to noise for order 10 """
        return self.SN10[spec_i].astype(sci.float64)

    def sn50(self,spec_i):
        """ Return the signal to noise for order 50 """
        return self.SN50[spec_i].astype(sci.float64)

    def sn60(self,spec_i):
        """ Return the signal to noise for order 60 """
        return self.SN60[spec_i].astype(sci.float64)

    def airmass(self,spec_i):
        """ Return the average airmass """
        return self.Airmass[spec_i].astype(sci.float64)

    def airmassMed(self):
        """ Return the median of the average airmass """
        return sci.median(self.Airmass)

    def seeing(self,spec_i):
        """ Return the seeing """
        return self.Seeing[spec_i].astype(sci.float64)

    def contrast(self,spec_i):
        """ Return the CCF contrast [%] """
        return self.Contrast[spec_i].astype(sci.float64)

    def fwhm(self,spec_i):
        """ Return the CCF fwhm """
        return self.FWHM[spec_i].astype(sci.float64)

    def bis_span(self,spec_i):
        """ Return the CCF bis_span """
        return self.Bis_span[spec_i].astype(sci.float64)

    def n_spectra(self):
        """ Return the number of spectra in the data set """
        return self.N_spectra

    def n_order(self):
        """ Return the number of orders per spectra in the data set """
        return self.N_order

    def n_pix(self):
        """ Return the number of pixels for one order (CCD)"""
        return self.N_pix

    def resamp(self,wave1,flux1,wave2):
        """ Return the cubic spline of wave1 and flux1 evaluated on wave2 """
        spline = UnivariateSpline(wave1,flux1,k=3,s=0.0)
        return spline(wave2)

    def rootFile(self,spec_i):
        """ Return the root of .fits file """
        return self.root_file[spec_i]

    def e2ds_list(self):
        """ Return selected e2ds file list """
        return self.file_list



def create_master(data_dir, spectra_list, tmpl_ans, telluric_file, skip_bjd = 0, save_name = ''):
    spec = Spec(data_dir,spectra_list)
    spec.load_spec(tmpl_ans,rv_data_ans,special_bjd,special_bjd_interval,neglect_bjd, rv_avg, rv_avg_val)
    if skip_bjd == 0:
        rv_ccf_avg = spec.vrad_avrg()
        rv_ccf_median = spec.vrad_median()
        print ' * Number of selected spectra:',spec.n_spectra()
        print ' * '+ target+' average RV_ccf =',round(rv_ccf_avg,5),'km/s'
        print ' * '+ target+' median RV_ccf =',round(rv_ccf_median,5),'km/s'
        if abs(rv_ccf_avg - rv_ccf_median)>1:
            print 'rv error, check files!'
            raise SystemExit
        print ' * Creating Template...'

    med_spec_noBlaze, stellar_templ_noise, telluric_templ_noise, ref_wave, trim, master_telluric, pos_masked_orders, pos_masked_orders_binary = sci.array([[]]), sci.array([[]]), sci.array([[]]), sci.array([[]]), sci.array([]), sci.array([[]]), [], []
    for iteration in xrange(4):
        ax0 = 1
        for order_i in xrange(spec.n_order()):
            resamp_spec_noBlaze, telluric_aux, ax1, valid_values = sci.array([[]]), sci.array([[]]), 1, True
            for spec_i in xrange(spec.n_spectra()):
                if iteration == 0 and round(spec.bjd(spec_i),6) != round(skip_bjd,6):
                    # We resamp spectra and we evaluate them in a reference spectrum
                    noBlaze_spec = spec.subBlaze(spec_i,order_i)
                    if len(sci.where(noBlaze_spec == 0)[0]) == 0 and len(spec.flux(spec_i,order_i)[sci.isnan(noBlaze_spec)]) == 0:
                        resamp_spec_noBlaze, ax1 = sci.append(resamp_spec_noBlaze,[spec.resamp(spec.wave_restFrame(spec_i,order_i),noBlaze_spec,spec.wave_restFrame(spec.argbluer(),order_i))],axis=ax1), 0
                    else:
                        valid_values = False


                if iteration == 1 or iteration == 3 and round(spec.bjd(spec_i),6) != round(skip_bjd,6):
                    if iteration == 1:
                        template_blaze = spec.addBlaze(spec.resamp(spec.wave_starFrame(ref_wave[order_i],spec_i),med_spec_noBlaze[order_i],spec.wave(spec_i,order_i)),spec_i,order_i)
                    if iteration == 3:
                        pix_cleaned = sci.delete(sci.arange(spec.n_pix(),dtype='int'),pos_masked_orders[order_i])
                        template_blaze = spec.addBlaze(spec.resamp(spec.wave_starFrame(ref_wave[order_i],spec_i),med_spec_noBlaze[order_i],spec.wave(spec_i,order_i)),spec_i,order_i,used_pix=pix_cleaned)


                    non_valid = sci.where(med_spec_noBlaze[order_i] == 0)[0]
                    telluric_spectrum = spec.flux(spec_i,order_i)/template_blaze

                    if len(non_valid) != 0:
                        telluric_spectrum[non_valid] = sci.zeros(len(non_valid))

                    telluric_aux, ax1 = sci.append(telluric_aux,[telluric_spectrum],axis=ax1), 0


                if iteration == 2 and round(spec.bjd(spec_i),6) != round(skip_bjd,6):
                    # We resamp spectra and we evaluate them in a reference spectrum neglecting telluric zones
                    pix_cleaned = sci.delete(sci.arange(spec.n_pix(),dtype='int'),pos_masked_orders[order_i])
                    noBlaze_spec = spec.subBlaze(spec_i,order_i,used_pix=pix_cleaned)
                    
                    if len(sci.where(noBlaze_spec == 0)[0]) == 0 and len(spec.flux(spec_i,order_i)[sci.isnan(noBlaze_spec)]) == 0:
                        resamp_spec_noBlaze_aux = spec.resamp(spec.wave_restFrame(spec_i,order_i),noBlaze_spec,ref_wave[order_i])
                        if opt_tmpl_ans:
                            pos_masked_shifted = sci.searchsorted(ref_wave[order_i],spec.wave_restFrame(spec_i,order_i)[pos_masked_orders[order_i]])
                            pos_masked_shifted = pos_masked_shifted[sci.where((pos_masked_shifted >= 0) & (pos_masked_shifted <= spec.n_pix()-1))]
                            resamp_spec_noBlaze_aux[pos_masked_shifted] = sci.zeros(len(pos_masked_shifted))

                        resamp_spec_noBlaze, ax1 = sci.append(resamp_spec_noBlaze,[resamp_spec_noBlaze_aux],axis=ax1), 0

                    else:
                        valid_values = False


            if iteration == 0:
                ref_wave = sci.append(ref_wave,[spec.wave_restFrame(spec.argbluer(),order_i)],axis=ax0)
                # We trim the template spectrum edges for berv+vrad shifts
                trim_val = trim_rv(spec.wave_restFrame(spec.argredder(),order_i),spec.wave_restFrame(spec.argbluer(),order_i),spec.n_pix())
                trim = sci.append(trim,trim_val)


            if iteration == 0 or iteration == 2:
                # We obtain the median template spectrum for each order
                if valid_values:
                    median_values_pix, std_values_pix = sci.array([]), sci.array([])
                    for pix_i in xrange(spec.n_pix()):
                        if opt_tmpl_ans:
                            non_masked_pix = sci.where(resamp_spec_noBlaze[:,pix_i] != 0)[0]
                                
                        else:
                            if skip_bjd == 0:
                                non_masked_pix = sci.arange(spec.n_spectra())
                            else:
                                non_masked_pix = sci.arange(spec.n_spectra()-1)

                        if len(non_masked_pix) == 0:
                            median_value = 0
                        else:
                            median_value = sci.median(resamp_spec_noBlaze[:,pix_i][non_masked_pix])

                        median_values_pix = sci.append(median_values_pix,median_value)
                        if iteration == 2:
                            if len(non_masked_pix) == 0:
                                std_value = 0
                            else:
                                std_value = sci.std(resamp_spec_noBlaze[:,pix_i][non_masked_pix])/sci.sqrt(len(non_masked_pix))

                            std_values_pix = sci.append(std_values_pix,std_value)
                            

                    if iteration == 2:
                        stellar_templ_noise = sci.append(stellar_templ_noise,[std_values_pix],ax0)

                    med_spec_noBlaze, ax0 = sci.append(med_spec_noBlaze,[median_values_pix],axis=ax0), 0

                else:
                    if iteration == 2:
                        stellar_templ_noise = sci.append(stellar_templ_noise,[sci.zeros(spec.n_pix())],ax0)

                    med_spec_noBlaze, ax0 = sci.append(med_spec_noBlaze,[sci.zeros(spec.n_pix())],axis=ax0), 0


            if iteration == 1 or iteration == 3:
                if telluric_file.find('.npz') != -1:
                    try:
                        telluric = sci.load(telluric_file)
                        telluric_med = telluric['telluric'][order_i]
                        telluric_std = telluric['telluric_noise'][order_i]
                    except:
                        print '* '+telluric_file+' not found'
                        telluric_std = sci.std(telluric_aux,axis=0)/sci.sqrt(spec.n_spectra())
                        telluric_med = sci.median(telluric_aux,axis=0)
                        pass
                else:
                    telluric_std = sci.std(telluric_aux,axis=0)/sci.sqrt(spec.n_spectra())
                    telluric_med = sci.median(telluric_aux,axis=0)


                if iteration == 1:
                    # Tellurics detectet at 5sigma are neglected
                    med_filt_telluric = medfilt(telluric_med,49)
                    pos_masked = sci.where((telluric_med > med_filt_telluric+5.*telluric_std) | (telluric_med < med_filt_telluric-5.*telluric_std))[0]
                    pos_masked = add_elements(pos_masked,3,0,spec.n_pix())
                    pos_masked_orders.append(pos_masked)
                    # Binary mask with detected tellurics (to save)
                    pos_masked_orders_binary.append(binaryMask(sci.delete(sci.arange(spec.n_pix(),dtype='int'),pos_masked),spec.n_pix()))

                if iteration == 3:
                    telluric_templ_noise = sci.append(telluric_templ_noise,[telluric_std],axis=ax0)
                    master_telluric, ax0  = sci.append(master_telluric,[telluric_med],axis=ax0), 0


        if iteration == 1:
            med_spec_noBlaze = sci.array([[]])

        if plot_ans_tmpl and iteration == 3:
            for spec_i in xrange(spec.n_spectra()):
                for order_i in xrange(spec.n_order()):
                    template_blaze = spec.addBlaze(spec.resamp(spec.wave_starFrame(ref_wave[order_i],spec_i),med_spec_noBlaze[order_i],spec.wave(spec_i,order_i)),spec_i,order_i)
                    noise_blaze = spec.addBlaze(stellar_templ_noise[order_i],spec_i,order_i)
                    try:
                        template_process_plot(spec_i,order_i,spec.bjd(spec_i),trim_val,spec.wave(spec_i,order_i),spec.flux(spec_i,order_i),template_blaze,noise_blaze,spec.sigma_readout(spec_i),master_telluric[order_i])
                    except:
                        print ' * Error ploting the template obtaining process for order',str(order_i)
                        continue


    if save_ans or skip_bjd != 0:
        # Save template and the edge trim values
        if save_name == '':
            save_name = savename+'_template'


        sci.savez(data_dir+save_name, wave=ref_wave, template=med_spec_noBlaze, template_noise = stellar_templ_noise, telluric=master_telluric, telluric_noise = telluric_templ_noise, telluric_mask=pos_masked_orders_binary, trim=trim, medAirmass = spec.airmassMed())


    if plot_ans_tmpl:
        for order_i in xrange(spec.n_order()):
            pl.figure(0)
            pl.step(ref_wave[order_i][trim[order_i]:-trim[order_i]],med_spec_noBlaze[order_i][trim[order_i]:-trim[order_i]],'k',linewidth=1)

        pl.xlabel('Wavelength $[\AA]$')
        pl.ylabel('Template')
        pl.show()


def get_RV(data_dir, spectra_list, rv_a, rv_b, rv_step, neglect_order, dopp_slope, sig_clip, tmpl_ans, skip_bjd_tmpl_ans, rad_vel1_ans, telluric_file, stitching, proc_i, n_split):
    spec = Spec(data_dir,spectra_list[proc_i-n_split:proc_i])
    spec.load_spec(tmpl_ans,rv_data_ans,special_bjd,special_bjd_interval,neglect_bjd, rv_avg, rv_avg_val)
    proc = proc_i/n_split

    if not skip_bjd_tmpl_ans:
        if tmpl_ans == 'y':
            template = sci.load(data_dir+savename+'_template.npz')
        else:
            try:
                if tmpl_ans != 'y' and tmpl_ans.find('.npz') == -1:
                    tmpl_ans = data_dir+savename+'_template.npz'

                template = sci.load(tmpl_ans)

            except:
                print '* Stellar template '+tmpl_ans+' not found!'
                return False

        if neglect_tellurics_forced:
            telluric_mask = template['telluric_mask']

        template_wave, template_trim, telluric, template = template['wave'], template['trim'], template['telluric'], template['template']
        if telluric_file.find('.npz') != -1:
            try:
                telluric = sci.load(telluric_file)
                if neglect_tellurics_forced:
                    telluric_mask = telluric['telluric_mask']
                    
                telluric = telluric['telluric']

            except:
                print '* Telluric template '+telluric_file+' not found'
                pass


    bjd_array, rv, bis_chi2_array, ebis_chi2_array, rv_8, rv_6_8, rv_4_6, rv_2_4, rv_2, erv_8, erv_6_8, erv_4_6, erv_2_4, erv_2, e_rv_final, e_rv_bouchy, e_rv_chi2, e_rv_chi2_8, e_rv_chi2_6_8, e_rv_chi2_4_6, e_rv_chi2_2_4, e_rv_chi2_2, e_rv_fit, rvVoigt, berv_array, S_ind, Halpha_index, Chi2_Min, FWHM, Skew, total_pix_supr, valid_pix_supr, trim_pix_supr, telluric_pix_supr, outliers_pix_supr, sn10_array, sn50_array, sn60_array, seeing_array, airmass_array, contrast_array, fwhm_array, bis_span_array = sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([])

    print ' * Extracting Radial Velocity on process '+str(proc)+' for '+str(spec.n_spectra())+' spectra'

    for spec_i in xrange(spec.n_spectra()):
        index_comp = True
        if skip_bjd_tmpl_ans:
            create_master(data_dir, spectra_list, 'y', telluric_file, skip_bjd = spec.bjd(spec_i), save_name = savename+'_template_'+str(proc))
            template = sci.load(data_dir+savename+'_template_'+str(proc)+'.npz')
            if neglect_tellurics_forced:
                telluric_mask = template['telluric_mask']
                
            template_wave, template_trim, telluric, template = template['wave'], template['trim'], template['telluric'], template['template']

            if telluric_file.find('.npz') != -1:
                try:
                    telluric = sci.load(telluric_file)
                    if neglect_tellurics_forced:
                        telluric_mask = telluric['telluric_mask']

                    telluric = telluric['telluric']
                except:
                    pass

        e_rv_orders_aux, O_C, rad_vel_1 = sci.array([]), sci.array([]), 0
        e_rv_orders_aux_top, e_rv_orders_aux_bottom, e_rv_orders_aux_8, e_rv_orders_aux_6_8, e_rv_orders_aux_4_6, e_rv_orders_aux_2_4, e_rv_orders_aux_2 = sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([])

        if rad_vel1_ans:
            rad_vel_1 = spec.vrad(spec_i)
            fwhm_1iter = 5.
            iterations = [1]
        else:
            iterations = [0, 1]


        for iteration in iterations:
            rad_vel, chi2_rv, chi2_top_rv, chi2_bottom_rv, chi2_8_rv, chi2_6_8_rv, chi2_4_6_rv, chi2_2_4_rv, chi2_2_rv, scale_orders, trim_orders, N_val_pix_init, N_val_pix_valid, N_val_pix_valid_init, N_val_pix_trim, N_val_pix_trim_init, N_val_pix_tellurics, N_val_pix_tellurics_init, N_val_pix_outliers, N_val_pix_outliers_init, rad_velVoigt, S_ind_value, S_ind_value, Skew_value, fwhm_Voigt = sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), [], 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 99, 99, 99, 99


            if rv_a == 99 and rv_b == 99:
                rv_a, rv_b = spec.vrad_avrg() - 13., spec.vrad_avrg() + 13.

            if iteration == 0:
                rad_vel_min, rad_vel_max = rv_a, rv_b

            if iteration == 1:
                cut_top, cut_bottom, cut_8, cut_6_8, cut_4_6, cut_2_4, cut_2, oversampled, chi2_oversampled = [], [], [], [], [], [], [], False, 0
                if rv_a == 99 and rv_b == 99:
                    rad_vel_min, rad_vel_max = rad_vel_1-3.*fwhm_1iter, rad_vel_1+3.*fwhm_1iter
                else:
                    rad_vel_min, rad_vel_max = rv_a, rv_b


            rv_i = rad_vel_min
            while rv_i <= rad_vel_max:
                chi2_aux, chi2_aux_top, chi2_aux_bottom, chi2_aux_8, chi2_aux_6_8, chi2_aux_4_6, chi2_aux_2_4, chi2_aux_2, wave_aux, Ca_VK_HR = sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([])

                for order_i in xrange(spec.n_order()):
                    # We first obtain the zones used to calculate de chi2
                    if rv_i == rad_vel_min:
                        max_blueshift = template_wave[order_i]*(c+rad_vel_min)/(c+spec.berv(spec_i))
                        max_redshift  = template_wave[order_i]*(c+rad_vel_max)/(c+spec.berv(spec_i))
                        trim_blue = trim_rv(max_blueshift, spec.wave(spec_i,order_i), spec.n_pix())
                        trim_red  = trim_rv(max_redshift, spec.wave(spec_i,order_i), spec.n_pix())
                        if trim_blue >= trim_red:
                            trim_val = trim_blue
                        else:
                            trim_val = trim_red


                        trim_array_rv = sci.zeros(spec.n_pix(),dtype=int)
                        trim_array_rv[trim_val:-trim_val] = 1

                        trim_array_template = sci.zeros(spec.n_pix(),dtype=int)
                        trim_array_template[int(template_trim[order_i]):] = 1
                        if neglect_tellurics_forced:
                            valid_pix = add_elements(sci.where((telluric_mask[order_i] == 0) | (template[order_i] == 0) | (telluric[order_i] == 0) | (sci.isfinite(template[order_i]) == False))[0],trim_val,0,spec.n_pix())
                        else:
                            valid_pix = add_elements(sci.where((template[order_i] == 0) | (telluric[order_i] == 0) | (sci.isfinite(template[order_i]) == False))[0],trim_val,0,spec.n_pix())

                        valid_pix = binaryMask(sci.delete(sci.arange(spec.n_pix(),dtype='int'),valid_pix),spec.n_pix())

                        # Avoid CCD stitiching (see Dumusque+2015)
                        if stitching:
                            for stitch_i in xrange(1,8):
                                valid_pix[stitch_i*512-40:stitch_i*512+41] = 0

                        total_trim = sci.array([[]],dtype=int)
                        total_trim = sci.append(total_trim,[valid_pix],1)
                        total_trim = sci.append(total_trim,[trim_array_template],0)
                        total_trim = sci.append(total_trim,[trim_array_rv],0)
                        trim_orders.append((sci.sum(total_trim,axis=0) == 3))


                    if ((len(sci.where(neglect_order == order_i)[0])) == 0) and (sci.average(template[order_i]) != 1.) and (sci.median(spec.flux(spec_i,order_i)) >= 20.):
                        # Apply a Doppler shift to the template in the barycenter frame
                        doppler_shift = (c+rv_i)/(c+spec.berv(spec_i))
                        template_spline = UnivariateSpline(template_wave[order_i]*doppler_shift,template[order_i],k=3,s=0.0)
                        shifted_template = template_spline(spec.wave(spec_i,order_i))
                        shifted_template_blaze = spec.blaze(spec_i,order_i)*shifted_template

                        if iteration == 0:
                            scale_coef_stellar = sci.median(spec.flux(spec_i,order_i)[trim_orders[order_i]])/sci.median(shifted_template_blaze[trim_orders[order_i]])
                            template_blaze = scale_coef_stellar*shifted_template_blaze
                            template_noise = sci.sqrt(template_blaze+spec.sigma_readout(spec_i)**2).real
                            O_C_vrad_i = ((spec.flux(spec_i,order_i) - template_blaze) / template_noise).real[trim_orders[order_i]]
                            check_O_C_vrad_i = sci.where(sci.isfinite(O_C_vrad_i) == True)
                            chi2_aux = sci.append(chi2_aux,O_C_vrad_i[check_O_C_vrad_i])
                            wave_aux = sci.append(wave_aux,spec.wave(spec_i,order_i)[trim_orders[order_i]][check_O_C_vrad_i])


                        if iteration == 1:
                            if rv_i == rad_vel_min:
                                # Apply the blaze function and scale the telluric template to an obseverd spectrum and we locate problematic zones
                                telluric_blaze = spec.blaze(spec_i,order_i)*telluric[order_i]
                                scale_coef_tellur = sci.median(spec.flux(spec_i,order_i)[trim_orders[order_i]])/sci.median(telluric_blaze[trim_orders[order_i]])
                                telluric_scale = scale_coef_tellur*telluric_blaze
                                slope_tellur = slope_calc(spec.wave(spec_i,order_i),telluric_scale,int(slope_width))

                                template_spline_rad_vel_1 = UnivariateSpline(template_wave[order_i]*(c+rad_vel_1)/(c+spec.berv(spec_i)),template[order_i],k=3,s=0.0)
                                shifted_template_rad_vel_1 = template_spline_rad_vel_1(spec.wave(spec_i,order_i))
                                shifted_template_blaze_rad_vel_1 = spec.blaze(spec_i,order_i)*shifted_template_rad_vel_1
                                scale_coef_stellar_1 = sci.median(spec.flux(spec_i,order_i)[trim_orders[order_i]])/sci.median((shifted_template_blaze_rad_vel_1*telluric[order_i])[trim_orders[order_i]])
                                template_blaze_rad_vel_1 = scale_coef_stellar_1*shifted_template_blaze_rad_vel_1
                                slope_obs = slope_calc(spec.wave(spec_i,order_i),template_blaze_rad_vel_1,int(slope_width))

                                if neglect_tellurics_slope:
                                    slope_ratio = sci.absolute(slope_obs)/sci.absolute(slope_tellur)
                                    doppler_zones = sci.where(slope_ratio > dopp_slope)[0]
                                    doppler_zones = binaryMask(doppler_zones,spec.n_pix())
                                    total_trim = sci.append(total_trim,[doppler_zones],0)
                                    total_trim_dopp = (sci.sum(total_trim,axis=0) == 4)
                                else:
                                    total_trim_dopp = trim_orders[order_i]
                                

                                # We analyse the residues
                                scale_coef_stellar_1 = sci.median(spec.flux(spec_i,order_i)[total_trim_dopp])/sci.median(shifted_template_blaze_rad_vel_1[total_trim_dopp])
                                template_blaze_rad_vel_1 = scale_coef_stellar_1*shifted_template_blaze_rad_vel_1
                                O_C_aux = ((spec.flux(spec_i,order_i) - template_blaze_rad_vel_1) / (sci.sqrt(template_blaze_rad_vel_1 + spec.sigma_readout(spec_i)**2)).real)

                                """
                                try:
                                    bins_width = 3.5*sci.std(O_C_aux)/(len(O_C_aux)**(1./3)) #Scott's normal reference rule
                                    O_C_dist_param = hist_param(O_C_aux,-10,10,bins_width)
                                    O_C_center, O_C_width = O_C_dist_param[1], O_C_dist_param[2]

                                except:
                                    O_C_center = 0.
                                """

                                # we perform a sigma clipping to correctly calculate the scale coefficient
                                outliers_pos = sci.where(sci.absolute(O_C_aux) > sig_clip)[0]
                                outliers_pos = add_elements(outliers_pos,30,0,spec.n_pix())
                                no_outliers = binaryMask(sci.delete(sci.arange(spec.n_pix(),dtype='int'),outliers_pos),spec.n_pix())
                                total_trim = sci.append(total_trim,[no_outliers],0)
                                trim_orders.pop(order_i)
                                if neglect_tellurics_slope:
                                    trim_orders.insert(order_i,(sci.sum(total_trim,axis=0) == 5))
                                else:
                                    trim_orders.insert(order_i,(sci.sum(total_trim[:4],axis=0) == 4))


                                scale_coef_stellar_1 = sci.median(spec.flux(spec_i,order_i)[trim_orders[order_i]])/sci.median(shifted_template_blaze_rad_vel_1[trim_orders[order_i]])
                                scale_orders = sci.append(scale_orders,scale_coef_stellar_1)
                                template_blaze_rad_vel_1 = scale_coef_stellar_1*shifted_template_blaze_rad_vel_1

                                # Uncomment to compute slopes with window size different from "slope_width", which are used to estimate the RV uncertainty
                                #slope_width2 = 3
                                #slope_obs = slope_calc(spec.wave(spec_i,order_i),template_blaze_rad_vel_1,slope_width2)

                                # We compute de RV error (bouchy method) through the RV from first iteration, we obtain the neglected pixels 
                                # and O-C to be used for the sigma clipping and obtain the skewness (strong skewness means some issue)
                                A_w = template_blaze_rad_vel_1[trim_orders[order_i]]
                                W = sci.sum((spec.wave(spec_i,order_i)[trim_orders[order_i]])**2*(slope_obs[trim_orders[order_i]])**2/(A_w+spec.sigma_readout(spec_i)**2))
                                #Q = sci.sqrt(W)/sci.sqrt(sci.sum(A_w))
                                erv = c/sci.sqrt(W)
                                e_rv_orders_aux = sci.append(e_rv_orders_aux,erv.real)

                                N_val_pix_init = N_val_pix_init + spec.n_pix()
                                N_val_pix_valid = N_val_pix_valid + len(sci.where(valid_pix == 0)[0])
                                N_val_pix_valid_init = N_val_pix_valid_init + len(sci.where(valid_pix == 1)[0])
                                N_val_pix_trim = N_val_pix_trim + 2.*trim_val

                                if neglect_tellurics_slope:
                                    N_val_pix_tellurics = N_val_pix_tellurics + len(sci.where(doppler_zones == 0)[0])
                                    N_val_pix_tellurics_init = N_val_pix_tellurics_init + len(sci.where(doppler_zones == 1)[0])
                                    N_val_pix_outliers = N_val_pix_outliers + len(sci.where(no_outliers == 0)[0])
                                    N_val_pix_outliers_init = N_val_pix_outliers_init + len(sci.where(no_outliers == 1)[0])

                                O_C_aux = (spec.flux(spec_i,order_i) - template_blaze_rad_vel_1) / (sci.sqrt(template_blaze_rad_vel_1+spec.sigma_readout(spec_i)**2)).real
                                O_C = sci.append(O_C,O_C_aux[trim_orders[order_i]])

                                # We compute the second derivative to distinguish upper and lower parts of spectral lines
                                if compute_activity_ind:
                                    slope_width2 = 3
                                    slope_obs2 = slope_calc(spec.wave(spec_i,order_i),slope_obs,slope_width2)
                                    cut_top.append(sci.where(slope_obs2[trim_orders[order_i]] < 0)[0])
                                    cut_bottom.append(sci.where(slope_obs2[trim_orders[order_i]] > 0)[0])

                                    # Different spectral zones are recovered considering the line depths
                                    reNorm_template = spec.re_norm(spec.wave(spec_i,order_i), shifted_template_rad_vel_1, 200, trim=trim_val)[trim_orders[order_i]]
                                    cut_8.append(sci.where(reNorm_template >= 0.8))
                                    cut_6_8.append(sci.where((reNorm_template >= 0.6) & (reNorm_template < 0.8)))
                                    cut_4_6.append(sci.where((reNorm_template >= 0.4) & (reNorm_template < 0.6)))
                                    cut_2_4.append(sci.where((reNorm_template >= 0.2) & (reNorm_template < 0.4)))
                                    cut_2.append(sci.where(reNorm_template < 0.2))

                                    W_top = sci.sum((spec.wave(spec_i,order_i)[trim_orders[order_i]][cut_top[order_i]])**2*(slope_obs[trim_orders[order_i]][cut_top[order_i]])**2/(A_w[cut_top[order_i]]+spec.sigma_readout(spec_i)**2))
                                    erv_top_aux = (c/sci.sqrt(W_top)).real
                                    e_rv_orders_aux_top = sci.append(e_rv_orders_aux_top,erv_top_aux)

                                    W_bottom = sci.sum((spec.wave(spec_i,order_i)[trim_orders[order_i]][cut_bottom[order_i]])**2*(slope_obs[trim_orders[order_i]][cut_bottom[order_i]])**2/(A_w[cut_bottom[order_i]]+spec.sigma_readout(spec_i)**2))
                                    erv_bottom_aux = (c/sci.sqrt(W_bottom)).real
                                    e_rv_orders_aux_bottom = sci.append(e_rv_orders_aux_bottom,erv_bottom_aux)

                                    W_8 = sci.sum((spec.wave(spec_i,order_i)[trim_orders[order_i]][cut_8[order_i]])**2*(slope_obs[trim_orders[order_i]][cut_8[order_i]])**2/(A_w[cut_8[order_i]]+spec.sigma_readout(spec_i)**2))
                                    erv_8_aux = (c/sci.sqrt(W_8)).real
                                    e_rv_orders_aux_8 = sci.append(e_rv_orders_aux_8,erv_8_aux)

                                    W_6_8 = sci.sum((spec.wave(spec_i,order_i)[trim_orders[order_i]][cut_6_8[order_i]])**2*(slope_obs[trim_orders[order_i]][cut_6_8[order_i]])**2/(A_w[cut_6_8[order_i]]+spec.sigma_readout(spec_i)**2))
                                    erv_6_8_aux = (c/sci.sqrt(W_6_8)).real
                                    e_rv_orders_aux_6_8 = sci.append(e_rv_orders_aux_6_8,erv_6_8_aux)

                                    W_4_6 = sci.sum((spec.wave(spec_i,order_i)[trim_orders[order_i]][cut_4_6[order_i]])**2*(slope_obs[trim_orders[order_i]][cut_4_6[order_i]])**2/(A_w[cut_4_6[order_i]]+spec.sigma_readout(spec_i)**2))
                                    erv_4_6_aux = (c/sci.sqrt(W_4_6)).real
                                    e_rv_orders_aux_4_6 = sci.append(e_rv_orders_aux_4_6,erv_4_6_aux)

                                    W_2_4 = sci.sum((spec.wave(spec_i,order_i)[trim_orders[order_i]][cut_2_4[order_i]])**2*(slope_obs[trim_orders[order_i]][cut_2_4[order_i]])**2/(A_w[cut_2_4[order_i]]+spec.sigma_readout(spec_i)**2))
                                    erv_2_4_aux = (c/sci.sqrt(W_2_4)).real
                                    e_rv_orders_aux_2_4 = sci.append(e_rv_orders_aux_2_4,erv_2_4_aux)

                                    W_2 = sci.sum((spec.wave(spec_i,order_i)[trim_orders[order_i]][cut_2[order_i]])**2*(slope_obs[trim_orders[order_i]][cut_2[order_i]])**2/(A_w[cut_2[order_i]]+spec.sigma_readout(spec_i)**2))
                                    erv_2_aux = (c/sci.sqrt(W_2)).real
                                    e_rv_orders_aux_2 = sci.append(e_rv_orders_aux_2,erv_2_aux)



                            template_blaze = scale_orders[order_i]*shifted_template_blaze
                            template_noise = sci.sqrt(template_blaze+spec.sigma_readout(spec_i)**2)
                            O_C_vrad_i = ((spec.flux(spec_i,order_i)-template_blaze)/template_noise).real[trim_orders[order_i]]
                            check_O_C_vrad_i = sci.where(sci.isfinite(O_C_vrad_i) == True)
                            chi2_aux = sci.append(chi2_aux,O_C_vrad_i[check_O_C_vrad_i])
                            wave_aux = sci.append(wave_aux,spec.wave(spec_i,order_i)[trim_orders[order_i]][check_O_C_vrad_i])


                            if compute_activity_ind:
                                chi2_aux_top = sci.append(chi2_aux_top,O_C_vrad_i[cut_top[order_i]])
                                chi2_aux_bottom = sci.append(chi2_aux_bottom,O_C_vrad_i[cut_bottom[order_i]])
                                chi2_aux_8   = sci.append(chi2_aux_8  ,O_C_vrad_i[cut_8[order_i]])
                                chi2_aux_6_8 = sci.append(chi2_aux_6_8,O_C_vrad_i[cut_6_8[order_i]])
                                chi2_aux_4_6 = sci.append(chi2_aux_4_6,O_C_vrad_i[cut_4_6[order_i]])
                                chi2_aux_2_4 = sci.append(chi2_aux_2_4,O_C_vrad_i[cut_2_4[order_i]])
                                chi2_aux_2   = sci.append(chi2_aux_2  ,O_C_vrad_i[cut_2[order_i]])



                    else:
                        e_rv_orders_aux = sci.append(e_rv_orders_aux,c)
                        scale_orders = sci.append(scale_orders,0)

                        if iteration == 1 and compute_activity_ind:
                            cut_top.append(0), cut_bottom.append(0), cut_8.append(0), cut_6_8.append(0), cut_4_6.append(0), cut_2_4.append(0), cut_2.append(0)
                            e_rv_orders_aux_top, e_rv_orders_aux_bottom, e_rv_orders_aux_8, e_rv_orders_aux_6_8, e_rv_orders_aux_4_6, e_rv_orders_aux_2_4, e_rv_orders_aux_2 = sci.append(e_rv_orders_aux_top,c), sci.append(e_rv_orders_aux_bottom,c), sci.append(e_rv_orders_aux_8,c), sci.append(e_rv_orders_aux_6_8,c), sci.append(e_rv_orders_aux_4_6,c), sci.append(e_rv_orders_aux_2_4,c), sci.append(e_rv_orders_aux_2,c)


                    # S, Halpha index calculation
                    if iteration == 1 and compute_activity_ind and rv_i == rad_vel_min and index_comp:
                        try:
                            if instrument == 'ESO':
                                open_trasmittance = sci.loadtxt(data_dir_tables+trasmittance_file,skiprows=2)
                            else:
                                #HARPN/SOPHIE trasmittance is not available
                                open_trasmittance[:,1] = sci.ones(len(open_trasmittance))


                            s1d =  openFits(glob(spec.rootFile(spec_i)+'_s1d_A.fits')[0])
                            Flux = s1d[0].data
                            crval, crpix, cdelt = s1d[0].header['CRVAL1'], s1d[0].header['CRPIX1'], s1d[0].header['CDELT1']
                            S_ind_value = activity_index(Flux, crval, crpix, cdelt, rad_vel_1, spec.bjd(spec_i), open_trasmittance, index_id='CaHK', plot=False)
                            Halpha_index_value = activity_index(Flux, crval, crpix, cdelt, rad_vel_1, spec.bjd(spec_i), open_trasmittance, index_id='Halpha', plot=False)
                            s1d.close()
                        except:
                            S_ind_value, Halpha_index_value = 99, 99
                            print ' * Error obtaining S_value'
                        index_comp = False



                N_val_pix_total = len(chi2_aux)

                if iteration == 0:
                    chi2 = sci.sum((chi2_aux)**2)/(N_val_pix_total-2.)

                if iteration == 1:
                    chi2 = sci.sum(chi2_aux**2)/(N_val_pix_total-2.)

                    if rv_i == rad_vel_min:
                        bins_width = 3.5*sci.std(O_C)/(len(O_C)**(1./3)) #Scott's normal reference rule
                        try:
                            Skew_value = (hist_param(O_C,-10,10,bins_width,ret_skew=True)[1]).real
                        except:
                            pass

                    if compute_activity_ind:
                        check_chi2_top = sci.where(sci.isfinite(chi2_aux_top) == True)
                        chi2_top = sci.sum(chi2_aux_top[check_chi2_top]**2)/(len(chi2_aux_top[check_chi2_top])-2.)
                        chi2_top_rv = sci.append(chi2_top_rv,chi2_top)

                        check_chi2_bottom = sci.where(sci.isfinite(chi2_aux_bottom) == True)
                        chi2_bottom = sci.sum(chi2_aux_bottom[check_chi2_bottom]**2)/(len(chi2_aux_bottom[check_chi2_bottom])-2.)
                        chi2_bottom_rv = sci.append(chi2_bottom_rv,chi2_bottom)

                        check_chi2_8 = sci.where(sci.isfinite(chi2_aux_8) == True)
                        chi2_8 = sci.sum(chi2_aux_8[check_chi2_8]**2)/(len(chi2_aux_8[check_chi2_8])-2.)
                        chi2_8_rv = sci.append(chi2_8_rv,chi2_8)

                        check_chi2_6_8 = sci.where(sci.isfinite(chi2_aux_6_8) == True)
                        chi2_6_8 = sci.sum(chi2_aux_6_8[check_chi2_6_8]**2)/(len(chi2_aux_6_8[check_chi2_6_8])-2.)
                        chi2_6_8_rv = sci.append(chi2_6_8_rv,chi2_6_8)

                        check_chi2_4_6 = sci.where(sci.isfinite(chi2_aux_4_6) == True)
                        chi2_4_6 = sci.sum(chi2_aux_4_6[check_chi2_4_6]**2)/(len(chi2_aux_4_6[check_chi2_4_6])-2.)
                        chi2_4_6_rv = sci.append(chi2_4_6_rv,chi2_4_6)

                        check_chi2_2_4 = sci.where(sci.isfinite(chi2_aux_2_4) == True)
                        chi2_2_4 = sci.sum(chi2_aux_2_4[check_chi2_2_4]**2)/(len(chi2_aux_2_4[check_chi2_2_4])-2.)
                        chi2_2_4_rv = sci.append(chi2_2_4_rv,chi2_2_4)

                        check_chi2_2 = sci.where(sci.isfinite(chi2_aux_2) == True)
                        chi2_2 = sci.sum(chi2_aux_2[check_chi2_2]**2)/(len(chi2_aux_2[check_chi2_2])-2.)
                        chi2_2_rv = sci.append(chi2_2_rv,chi2_2)


                chi2_rv = sci.append(chi2_rv,chi2)
                rad_vel = sci.append(rad_vel, rv_i)

                # We set the RV step
                if iteration == 0:
                    rv_i = rv_i + plate_scale

                if iteration == 1:
                    if fit_to_R and (rv_i <= rad_vel_1-(0.6*c/instr_R)*plate_scale or chi2 >= chi2_oversampled):
                        rv_i = rv_i + plate_scale/2.
                        if not oversampled:
                            chi2_oversampled = chi2

                    if fit_to_R and rv_i > rad_vel_1-(0.6*c/instr_R)*plate_scale and chi2 < chi2_oversampled:
                        if not oversampled:# and round(rad_vel[-1]-rad_vel[-2],3) == round(plate_scale/10.,3):
                            chi2_oversampled = chi2
                            oversampled = True
                        rv_i = rv_i + plate_scale/10.

                    if not fit_to_R and (rv_i <= rad_vel_1-0.6*plate_scale or chi2 >= chi2_oversampled):
                        rv_i = rv_i + plate_scale/2.
                        if not oversampled:
                            chi2_oversampled = chi2

                    if not fit_to_R and rv_i > rad_vel_1-0.6*plate_scale and chi2 < chi2_oversampled:
                        if not oversampled:# and round(rad_vel[-1]-rad_vel[-2],3) == round(plate_scale/10.,3):
                            chi2_oversampled = chi2
                            oversampled = True
                        rv_i = rv_i + plate_scale/10.


                if plot_ans_rv:
                    if iteration == 0:
                        bins_width, chi2_oversampled = 0.1, 0
                    else:
                        pos_OK = sci.isfinite(O_C)
                        bins_width = 3.5*sci.std(O_C[pos_OK])/(len(O_C[pos_OK])**(1./3))  #Scott's normal reference rule

                    plot_rv_process(spec, spec_i, rad_vel_min, rad_vel_max, rad_vel, rad_vel_1, rv_i, chi2_rv, chi2_aux, chi2_oversampled, wave_aux, bins_width, iteration)



            if iteration == 0:
                fitGauss_param, e_fitGauss_param, fitVoigt_param, e_fitVoigt_param = fit_correl(chi2_rv,rad_vel,(rad_vel_max-rad_vel_min)*0.5,spec_i,order_i,spec.bjd(spec_i))

                pos_min_correl, pos_max_correl = chi2_rv.argmin(), chi2_rv.argmax()
                pos_fwhm_correl = sci.where(chi2_rv < chi2_rv[pos_min_correl]+abs(chi2_rv[pos_min_correl]-chi2_rv[pos_max_correl])*0.5)[0]
                fwhm_1iter = abs(rad_vel[pos_fwhm_correl[-1]]-rad_vel[pos_fwhm_correl[0]])


            if iteration == 1:
                if fit_to_R:
                    bottom_fit = 0.5*c/instr_R
                else:
                    bottom_fit = 0.5*plate_scale

                fitGauss_param, e_fitGauss_param, fitVoigt_param, e_fitVoigt_param = fit_correl(chi2_rv,rad_vel,bottom_fit,spec_i,order_i,spec.bjd(spec_i))
                

                if compute_activity_ind:
                    try:
                        fitGauss_param_top, e_fitGauss_param_top, fitVoigt_param_top, e_fitVoigt_param_top = fit_correl(chi2_top_rv,rad_vel,bottom_fit,spec_i,order_i,spec.bjd(spec_i),plot=False)
                        fitGauss_param_bottom, e_fitGauss_param_bottom, fitVoigt_param_bottom, e_fitVoigt_param_bottom = fit_correl(chi2_bottom_rv,rad_vel,bottom_fit,spec_i,order_i,spec.bjd(spec_i),plot=False)
                    except:
                        continue

                    try:
                        fitGauss_param_8, e_fitGauss_param_8, fitVoigt_param_8, e_fitVoigt_param_8 = fit_correl(chi2_8_rv,rad_vel,bottom_fit,spec_i,order_i,spec.bjd(spec_i),plot=False)
                        rv_spec_8 = fitGauss_param_8[1]
                    except:
                        rv_spec_8 = 99

                    try:
                        fitGauss_param_6_8, e_fitGauss_param_6_8, fitVoigt_param_6_8, e_fitVoigt_param_6_8 = fit_correl(chi2_6_8_rv,rad_vel,bottom_fit,spec_i,order_i,spec.bjd(spec_i),plot=False)
                        rv_spec_6_8 = fitGauss_param_6_8[1]
                    except:
                        rv_spec_6_8 = 99

                    try:
                        fitGauss_param_4_6, e_fitGauss_param_4_6, fitVoigt_param_4_6, e_fitVoigt_param_4_6 = fit_correl(chi2_4_6_rv,rad_vel,bottom_fit,spec_i,order_i,spec.bjd(spec_i),plot=False)
                        rv_spec_4_6 = fitGauss_param_4_6[1]
                    except:
                        rv_spec_4_6 = 99

                    try:
                        fitGauss_param_2_4, e_fitGauss_param_2_4, fitVoigt_param_2_4, e_fitVoigt_param_2_4 = fit_correl(chi2_2_4_rv,rad_vel,bottom_fit,spec_i,order_i,spec.bjd(spec_i),plot=False)
                        rv_spec_2_4 = fitGauss_param_2_4[1]
                    except:
                        rv_spec_2_4 = 99

                    try:
                        fitGauss_param_2, e_fitGauss_param_2, fitVoigt_param_2, e_fitVoigt_param_2 = fit_correl(chi2_2_rv,rad_vel,bottom_fit,spec_i,order_i,spec.bjd(spec_i),plot=False)
                        rv_spec_2 = fitGauss_param_2[1]
                    except:
                        rv_spec_2 = 99

                else:
                    rv_spec_8, rv_spec_6_8, rv_spec_4_6, rv_spec_2_4, rv_spec_2 = 99, 99, 99, 99, 99



                # We save the chi2 profiles
                if save_ans:
                    chi2_file = open(spec.rootFile(spec_i)+'_chi2Profile.rdb','w')
                    if compute_activity_ind:
                        chi2_file.write('%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' % ('RV','chi2','chi2_top','chi2_bottom','chi2_8%','chi2_6-8%','chi2_4-6%','chi2_2-6%','chi2_2%'))
                        chi2_file.write('%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' % ('--','----','--------','-----------','-------','---------','---------','---------','-------'))
                        for RV_i in xrange(len(rad_vel)):
                            chi2_file.write('%.3f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\n' % (round(rad_vel[RV_i],3),round(chi2_rv[RV_i],6),round(chi2_top_rv[RV_i],6),round(chi2_bottom_rv[RV_i],6),round(chi2_8_rv[RV_i],6),round(chi2_6_8_rv[RV_i],6),round(chi2_4_6_rv[RV_i],6),round(chi2_2_4_rv[RV_i],6),round(chi2_2_rv[RV_i],6)))
                    else:
                        chi2_file.write('%s\t%s\n' % ('RV','chi2'))
                        chi2_file.write('%s\t%s\n' % ('--','----'))
                        for RV_i in xrange(len(rad_vel)):
                            chi2_file.write('%.3f\t%.6f\n' % (round(rad_vel[RV_i],3),round(chi2_rv[RV_i],6)))


                    chi2_file.close()

                if compute_activity_ind:
                    rv_bis = (fitGauss_param_top[1] - fitGauss_param_bottom[1])*1e3  # m/s
                else:
                    rv_bis = 99


                eGFit_contrast, eGFit_RV, eGFit_FWHM, eGFit_continuum  = e_fitGauss_param[0], e_fitGauss_param[1], e_fitGauss_param[2], e_fitGauss_param[3]
                eVfit_A, eVfit_RV, eVfit_al, eVfit_ad, eVfit_off = e_fitVoigt_param[0], e_fitVoigt_param[1], e_fitVoigt_param[2], e_fitVoigt_param[3], e_fitVoigt_param[4]

                if neglect_tellurics_slope:
                    percent_total_pix_supr, percent_valid_pix_supr, percent_trim_pix_supr, percent_telluric_pix_supr, percent_outliers_pix_supr = 100.*(1.-float(N_val_pix_total)/N_val_pix_init), 100.*(float(N_val_pix_valid)/N_val_pix_init), 100.*(float(N_val_pix_trim)/N_val_pix_init), 100.*(float(N_val_pix_tellurics)/N_val_pix_init), 100.*(float(N_val_pix_outliers)/N_val_pix_init)
                else:
                    percent_total_pix_supr, percent_valid_pix_supr, percent_trim_pix_supr, percent_telluric_pix_supr, percent_outliers_pix_supr = 100.*(1.-float(N_val_pix_total)/N_val_pix_init), 100.*(float(N_val_pix_valid)/N_val_pix_init), 100.*(float(N_val_pix_trim)/N_val_pix_init), 0, 0


                Chi2_min_value = fitGauss_param[0]+fitGauss_param[3]
                if fitVoigt_param[0] != 99:
                    fwhm_Voigt, rad_velVoigt = Voigt_FWHM(abs(fitVoigt_param[2]),abs(fitVoigt_param[3])), fitVoigt_param[1]
                else:
                    fwhm_Voigt, rad_velVoigt = 99, 99


            rv_spec = fitGauss_param[1]
            if rad_vel_1 == 0:
                rad_vel_1 = rv_spec

            e_rv_spec_bouchy = 1./sci.sqrt(sci.sum((1./e_rv_orders_aux[sci.where(e_rv_orders_aux != c)])**2))
            e_rv_spec_chi2 = fitGauss_param[2]*sci.sqrt(sci.log(((N_val_pix_total-2.)*fitGauss_param[0]/((N_val_pix_total-2.)*fitGauss_param[0]+1.))**2))
            # An quadratinc RV uncertainty (60 cm/s) is added
            e_rv_spec_final = sci.sqrt(e_rv_spec_bouchy**2+(6e-4)**2)

            if compute_activity_ind:
                e_rv_spec_top = 1./sci.sqrt(sci.sum((1./e_rv_orders_aux_top[sci.where(e_rv_orders_aux_top != c)])**2))
                e_rv_spec_bottom = 1./sci.sqrt(sci.sum((1./e_rv_orders_aux_bottom[sci.where(e_rv_orders_aux_bottom != c)])**2))
                e_rv_spec_8 = 1./sci.sqrt(sci.sum((1./e_rv_orders_aux_8[sci.where(e_rv_orders_aux_8 != c)])**2))
                e_rv_spec_6_8 = 1./sci.sqrt(sci.sum((1./e_rv_orders_aux_6_8[sci.where(e_rv_orders_aux_6_8!= c)])**2))
                e_rv_spec_4_6 = 1./sci.sqrt(sci.sum((1./e_rv_orders_aux_4_6[sci.where(e_rv_orders_aux_4_6!= c)])**2))
                e_rv_spec_2_4 = 1./sci.sqrt(sci.sum((1./e_rv_orders_aux_2_4[sci.where(e_rv_orders_aux_2_4!= c)])**2))
                e_rv_spec_2 = 1./sci.sqrt(sci.sum((1./e_rv_orders_aux_2[sci.where(e_rv_orders_aux_2!= c)])**2))
            else:
                e_rv_spec_top, e_rv_spec_bottom, e_rv_spec_8, e_rv_spec_6_8, e_rv_spec_4_6, e_rv_spec_2_4, e_rv_spec_2 = 99, 99, 99, 99, 99, 99, 99



            if iteration == 1:
                if len(bjd_array) > 0:
                    pos_toIns = sci.searchsorted(bjd_array,spec.bjd(spec_i)-2400000.)
                    
                else:
                    pos_toIns = 0

                bjd_array = sci.insert(bjd_array, pos_toIns, round(spec.bjd(spec_i)-2400000.,6))
                rv = sci.insert(rv, pos_toIns, round(rv_spec,5))
                e_rv_final = sci.insert(e_rv_final, pos_toIns, round(e_rv_spec_final,5))
                fwhm_array = sci.insert(fwhm_array, pos_toIns, round(spec.fwhm(spec_i),5))
                contrast_array = sci.insert(contrast_array, pos_toIns, round(spec.contrast(spec_i),5))
                bis_span_array = sci.insert(bis_span_array, pos_toIns, round(spec.bis_span(spec_i)*1e3,3))
                sn10_array = sci.insert(sn10_array, pos_toIns, spec.sn10(spec_i))
                sn50_array = sci.insert(sn50_array, pos_toIns, spec.sn50(spec_i))
                sn60_array = sci.insert(sn60_array, pos_toIns, spec.sn60(spec_i))
                seeing_array = sci.insert(seeing_array, pos_toIns, spec.seeing(spec_i))
                airmass_array = sci.insert(airmass_array, pos_toIns, spec.airmass(spec_i))
                e_rv_bouchy = sci.insert(e_rv_bouchy, pos_toIns, round(e_rv_spec_bouchy,5))
                e_rv_chi2 = sci.insert(e_rv_chi2, pos_toIns, round(abs(e_rv_spec_chi2),5))
                e_rv_fit = sci.insert(e_rv_fit, pos_toIns, round(sci.sqrt(eGFit_RV)*1e3,3))
                rvVoigt = sci.insert(rvVoigt , pos_toIns, round(rad_velVoigt,5))
                berv_array = sci.insert(berv_array, pos_toIns, round(spec.berv(spec_i),5))
                Chi2_Min = sci.insert(Chi2_Min, pos_toIns, round(Chi2_min_value,5))
                FWHM = sci.insert(FWHM, pos_toIns, round(fwhm_Voigt,5))
                Skew = sci.insert(Skew, pos_toIns, round(Skew_value,5))
                total_pix_supr = sci.insert(total_pix_supr, pos_toIns, round(percent_total_pix_supr,1))
                valid_pix_supr = sci.insert(valid_pix_supr, pos_toIns, round(percent_valid_pix_supr,1))
                trim_pix_supr = sci.insert(trim_pix_supr, pos_toIns, round(percent_trim_pix_supr,1))
                telluric_pix_supr = sci.insert(telluric_pix_supr, pos_toIns, round(percent_telluric_pix_supr,1))
                outliers_pix_supr = sci.insert(outliers_pix_supr, pos_toIns, round(percent_outliers_pix_supr,1))
                if compute_activity_ind:
                    S_ind_value, Halpha_index_value, rv_bis = round(S_ind_value,5), round(Halpha_index_value,5), round(rv_bis,3)
                    ebis_chi2 = 1e3*sci.sqrt(e_rv_spec_top**2+e_rv_spec_bottom**2)/sci.sqrt(2.) # m/s
                    rv_spec_8, e_rv_spec_8 = round(rv_spec_8,5), round(e_rv_spec_8,5)
                    rv_spec_6_8, e_rv_spec_6_8 = round(rv_spec_6_8,5), round(e_rv_spec_6_8,5)
                    rv_spec_4_6, e_rv_spec_4_6 = round(rv_spec_4_6,5), round(e_rv_spec_4_6,5)
                    rv_spec_2_4, e_rv_spec_2_4 = round(rv_spec_2_4,5), round(e_rv_spec_2_4,5)
                    rv_spec_2, e_rv_spec_2 = round(rv_spec_2,5), round(e_rv_spec_2,5)
                else:
                    S_ind_value, Halpha_index_value, rv_bis = 99, 99, 99
                    ebis_chi2 = 99
                    rv_spec_8, e_rv_spec_8, rv_spec_6_8, e_rv_spec_6_8 = 99, 99, 99, 99
                    rv_spec_4_6, e_rv_spec_4_6, rv_spec_2_4, e_rv_spec_2_4 = 99, 99, 99, 99
                    rv_spec_2, e_rv_spec_2 = 99, 99

                S_ind = sci.insert(S_ind, pos_toIns, S_ind_value)
                Halpha_index = sci.insert(Halpha_index, pos_toIns, Halpha_index_value)
                bis_chi2_array = sci.insert(bis_chi2_array, pos_toIns, rv_bis)
                ebis_chi2_array = sci.insert(ebis_chi2_array, pos_toIns, ebis_chi2)
                rv_8 = sci.insert(rv_8, pos_toIns, rv_spec_8)
                erv_8 = sci.insert(erv_8, pos_toIns, e_rv_spec_8)
                rv_6_8 = sci.insert(rv_6_8, pos_toIns, rv_spec_6_8)
                erv_6_8 = sci.insert(erv_6_8, pos_toIns, e_rv_spec_6_8)
                rv_4_6 = sci.insert(rv_4_6, pos_toIns, rv_spec_4_6)
                erv_4_6 = sci.insert(erv_4_6, pos_toIns, e_rv_spec_4_6)
                rv_2_4 = sci.insert(rv_2_4, pos_toIns, rv_spec_2_4)
                erv_2_4 = sci.insert(erv_2_4, pos_toIns, e_rv_spec_2_4)
                rv_2 = sci.insert(rv_2, pos_toIns, rv_spec_2)
                erv_2 = sci.insert(erv_2, pos_toIns, e_rv_spec_2)

                print ' * Spectrum BJD '+str(round(spec.bjd(spec_i)-2450000.,5))+'; Supr pix total[%]: '+str(round(percent_total_pix_supr,1))+'; RV = '+str(('%.5f' % round(rv_spec,5)))+'+-'+str(('%.5f' % round(e_rv_spec_final,5)))


        if skip_bjd_tmpl_ans:
            os.system('rm '+data_dir+savename+'_template_'+str(proc)+'.npz')


    if save_ans:
        if N_proc > 1:
            to_file = open(data_dir+savename+'_NAIRA_v1_'+str(proc)+'.rdb','w')
        if N_proc == 1:
            to_file = open(data_dir+savename+'_w'+str(slope_width)+'_s'+str(dopp_slope)+'_c'+str(sig_clip)+'_'+'_NAIRA_v1.rdb','w')

            
        if instrument == 'ESO' or instrument == 'TNG':
            sn_a, sn_b, sn_c = 'sn10','sn50','sn60'
        if instrument == 'OHP':
            sn_a, sn_b, sn_c = 'sn4','sn27','sn32'

        to_file.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % ('jdb','vrad','svrad','s_mw','Halpha','fwhm','contrast','bis_span','bis_chi2','ebis_chi2','vrad20%','evrad20%','vrad40-20%','evrad40-20%','vrad60-40%','evrad60-40%','vrad80-60%','evrad80-60%','vrad80%','evrad80%',sn_a, sn_b, sn_c,'seeing','airmass','svrad_bouchy','svrad_chi2','svrad_GFit','vrad_Voigt','berv','chi2_min','chi2_fwhm','Skew','%Supr_Total','%Supr_ValidPix','%Supr_Trim','%Supr_Telluric','%Supr_Outliers'))
        to_file.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % ('---','----','-----','----','------','----','--------','--------','--------','--------','-------','--------','----------','------------','----------','-----------','----------','-----------','-------','--------','----','----','----','------','-------','------------','----------','----------','----------','----','--------','---------','----','-----------','--------------','----------','--------------','--------------'))
        for spec_i in xrange(spec.n_spectra()):
            to_file.write("%.6f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.3f\t%.3f\t%.3f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.1f\t%.1f\t%.1f\t%.1f\t%.1f\n" % (bjd_array[spec_i], rv[spec_i], e_rv_final[spec_i], S_ind[spec_i], Halpha_index[spec_i], fwhm_array[spec_i], contrast_array[spec_i], bis_span_array[spec_i], bis_chi2_array[spec_i], ebis_chi2_array[spec_i], rv_8[spec_i], erv_8[spec_i], rv_6_8[spec_i], erv_6_8[spec_i], rv_4_6[spec_i], erv_4_6[spec_i], rv_2_4[spec_i], erv_2_4[spec_i], rv_2[spec_i], erv_2[spec_i], sn10_array[spec_i], sn50_array[spec_i], sn60_array[spec_i], seeing_array[spec_i], airmass_array[spec_i], e_rv_bouchy[spec_i], e_rv_chi2[spec_i], e_rv_fit[spec_i], rvVoigt[spec_i], berv_array[spec_i], Chi2_Min[spec_i], FWHM[spec_i], Skew[spec_i], total_pix_supr[spec_i], valid_pix_supr[spec_i], trim_pix_supr[spec_i], telluric_pix_supr[spec_i], outliers_pix_supr[spec_i]))

        to_file.close()

    if plot_ans_rv:
        pl.close()
        pl.ioff()



def add_elements(elem, n_elem, elem_a, elem_b):
    """ Add n_elem consecutive positionss to each side of elements in an array. Elements are in the range [elem_a, elem_b] """
    if len(elem) == 0:
        return elem

    for i in xrange(-n_elem,n_elem+1,1):
        aux1, aux2 = sci.array([[]]), sci.array([[]])
        if i < 0:
            aux1 = sci.append(aux1,[elem[1:]],1)
            aux1 = sci.append(aux1,[-elem[:-1]],0)
            elem = sci.append(elem,(elem-1)[sci.where(sci.insert(sci.sum(aux1,axis=0),0,0) != 1)])
            elem.sort()

        if i > 0:
            aux2 = sci.append(aux2,[-elem[:-1]],1)
            aux2 = sci.append(aux2,[elem[1:]],0)
            elem = sci.append(elem,(elem+1)[sci.where(sci.append(sci.sum(aux2,axis=0),0) != 1)])
            elem.sort()

    elem = elem[sci.where((elem >= elem_a) & (elem <= elem_b-1))]

    return elem



def hist_param(y, x_a, x_b, bin_step, ret_skew=False):
    """ Fit Gauss to an histogram and return parameters """ 
    bin_array = sci.arange(x_a,x_b+bin_step,bin_step)
    n, bins = sci.histogram(y,bins=bin_array)
    bins = bins[:-1]
    med_n, pos_min_n = sci.median(n), n.argmax()
    start_to_fit = sci.array([n[pos_min_n]-med_n,bins[pos_min_n],0.5,0])
    fitGauss_param = curve_fit(Gauss,bins,n,start_to_fit,maxfev=10000)[0]

    if ret_skew:
        Skew_value = skew(y)

        return fitGauss_param,Skew_value
    else:
        return fitGauss_param


def binaryMask(selected, n_pix, bool_type=False):
    """ Create a binary mask from selected zones """
    mask = sci.zeros(n_pix,dtype='int')
    n_elem = len(selected)
    if n_elem == 0:
        selected = sci.zeros(n_pix,dtype='int')

    mask[selected] = 1
    if bool_type:
        mask = sci.array(mask, dtype=bool)

    return mask


"""
def slope_calc(x, y, N_elem):
    Calculate the slope for a pixel using a linear fit to N_elem elements centered on the pixel of interest (N_elem should be odd)
    fit = lambda z: sci.polyfit(z[0], z[1], 1)[0]
    z_N_elem = sci.array([[sci.roll(x,i-N_elem/2), sci.roll(y,i-N_elem/2)] for i in xrange(N_elem)]).T
    slope = sci.transpose(sci.asarray(map(fit, z_N_elem)))
    slope[:N_elem/2] = 0
    slope[-N_elem/2+1:] = 0

    return slope
"""
def slope_calc(x, y, N_elem):
    """ Calculate the slope for a pixel using linear regression to N_elem elements centered on the pixel of interest """
    fit = lambda z: ((z[0]*z[1]).mean()-z[0].mean()*z[1].mean())/((z[0]**2).mean()-(z[0].mean())**2)
    z_N_elem = sci.array([[sci.roll(x,i-N_elem/2), sci.roll(y,i-N_elem/2)] for i in xrange(N_elem)]).T
    slope = sci.transpose(sci.asarray(map(fit, z_N_elem)))
    return slope


def trim_rv(wave1, wave2, N_pix):
    """ compute the number of elements before/after the beginning/end of two wavelength solutions  """
    if sci.absolute(wave1[0]-wave2[0]) < sci.absolute(wave1[-1]-wave2[-1]):
        if wave1[-1] < wave2[-1]:
            max_trim = N_pix - sci.searchsorted(wave2,wave1[-1])
        else:
            max_trim = N_pix - sci.searchsorted(wave1,wave2[-1])

    else:
        if wave1[0] < wave2[0]:
            max_trim = sci.searchsorted(wave1,wave2[0])

        else:
            max_trim = sci.searchsorted(wave2,wave1[0])

    return int(max_trim)


def trim_blaze(spec, spec_i, order_i):
    """  Trim the edges according to where the blaze function is greater than the adjacent ones (usually in the intercept) """
    if order_i >= 1 and order_i <= spec.n_order()-2:
        trim_array = sci.zeros(spec.n_pix(),dtype=int)
        blend1 = sci.searchsorted(spec.wave(spec_i, order_i-1), spec.wave(spec_i, order_i)[0])
        if blend1 != spec.n_pix():
            spl_blend1 = UnivariateSpline(spec.wave(spec_i, order_i-1)[blend1:], spec.blaze(spec_i, order_i-1)[blend1:], k=3,s=0.0)
            ratio1 = (spec.blaze(spec_i, order_i)[:spec.n_pix()-blend1])/(spl_blend1(spec.wave(spec_i, order_i)[:spec.n_pix()-blend1]))
            try:
                trim1 = sci.where(ratio1 >= 1)[0][0]
                trim1_1 = sci.searchsorted(spec.wave(spec_i, order_i-1), spec.wave(spec_i, order_i)[trim1])
            except:
                trim1, trim1_1 = spec.n_pix()-blend1, spec.n_pix()-blend1

        else:
            trim1, trim1_1 = 0, spec.n_pix()


        blend2 = sci.searchsorted(spec.wave(spec_i, order_i+1), spec.wave(spec_i, order_i)[-1])
        if blend2 != 0:
            spl_blend2 = UnivariateSpline(spec.wave(spec_i, order_i+1)[:blend2], spec.blaze(spec_i, order_i+1)[:blend2], k=3,s=0.0)
            ratio2 = (spl_blend2(spec.wave(spec_i, order_i)[-blend2:]))/(spec.blaze(spec_i, order_i)[-blend2:])
            try:
                trim2 = sci.where(ratio2 >= 1)[0][0]
                trim2_1 = sci.searchsorted(spec.wave(spec_i, order_i+1), spec.wave(spec_i, order_i)[-blend2+trim2])
            except:
                blend2, trim2, trim2_1 = 0, spec.n_pix(), 0

            if blend2 == trim2:
                blend2, trim2 = 0, spec.n_pix()

        else:
            trim2 ,trim2_1 = spec.n_pix(), 0


        if order_i == 1:
            trim_array[:trim1_1] = 1

        if order_i == spec.n_order()-2:
            trim_array[trim2_1:] = 1

        if order_i != 1 and order_i != spec.n_order()-2:
            trim_array[trim1:-blend2+trim2] = 1


    else:
        trim_array = sci.ones(spec.n_pix(),dtype=int)

    return trim_array




def fit_correl(correl_order, rad_vel, rv_range, spec_i, order_i, bjd, fit_Voigt=True, plot=True):
    """ Fit a gaussian to around the minimum of the chi2 distribution and/or a voigtian in the RV domain """
    fitGauss_param, e_fitGauss_param, fitVoigt_param, e_fitVoigt_param, green = [99,99,99,99], [99,99,99,99], [99,99,99,99,99], [99,99,99,99,99], False
    pos_min_correl = correl_order.argmin()
    rv_cut_a, rv_cut_b = sci.searchsorted(rad_vel,sci.array([rad_vel[pos_min_correl]-rv_range,rad_vel[pos_min_correl]+rv_range]))
    pos_min_correl, pos_max_correl = (correl_order[rv_cut_a:rv_cut_b]).argmin(),(correl_order[rv_cut_a:rv_cut_b]).argmax()
    pos_fwhm_correl = sci.where(correl_order[rv_cut_a:rv_cut_b] < correl_order[rv_cut_a:rv_cut_b][pos_min_correl]+abs(correl_order[rv_cut_a:rv_cut_b][pos_min_correl]-correl_order[rv_cut_a:rv_cut_b][pos_max_correl])*0.5)[0]

    try:
        gauss_guess = sci.array([correl_order[rv_cut_a:rv_cut_b][pos_min_correl]-correl_order[rv_cut_a:rv_cut_b][pos_max_correl],rad_vel[rv_cut_a:rv_cut_b][pos_min_correl],abs(rad_vel[rv_cut_a:rv_cut_b][pos_fwhm_correl[-1]]-rad_vel[rv_cut_a:rv_cut_b][pos_fwhm_correl[0]]),correl_order[rv_cut_a:rv_cut_b][pos_max_correl]])
        fitGauss_param, covMatrix_fitGauss_param = curve_fit(Gauss,rad_vel[rv_cut_a:rv_cut_b],correl_order[rv_cut_a:rv_cut_b],gauss_guess,maxfev=10000)
        e_fitGauss_param = sci.array([covMatrix_fitGauss_param[0,0], covMatrix_fitGauss_param[1,1], covMatrix_fitGauss_param[2,2], covMatrix_fitGauss_param[3,3]])
        green = True
        if fit_Voigt:
            try:
                pos_min_correl_V, pos_max_correl_V = correl_order.argmin(),correl_order.argmax()
                pos_fwhm_correl_V = sci.where(correl_order < correl_order[pos_min_correl_V]+abs(correl_order[pos_min_correl_V]-correl_order[pos_max_correl_V])*0.5)[0]
                voigt_guess = sci.array([correl_order[pos_min_correl_V]-correl_order[pos_max_correl_V],rad_vel[pos_min_correl_V],abs(rad_vel[pos_fwhm_correl_V[-1]]-rad_vel[pos_fwhm_correl_V[0]]),abs(rad_vel[pos_fwhm_correl_V[-1]]-rad_vel[pos_fwhm_correl_V[0]]),correl_order[pos_max_correl_V]])
                fitVoigt_param, covMatrix_fitVoigt_param = curve_fit(Voigt,rad_vel,correl_order,voigt_guess,maxfev=10000)
                e_fitVoigt_param = sci.array([covMatrix_fitVoigt_param[0,0], covMatrix_fitVoigt_param[1,1], covMatrix_fitVoigt_param[2,2], covMatrix_fitVoigt_param[3,3], covMatrix_fitVoigt_param[4,4]])
            except:
                pass

    except:
        print '    * Error finding chi2 minimum (fitting) on spectrum bjd:',bjd


    if plot_ans_rv and green and plot:
        plot_correl(correl_order,fitGauss_param,fitVoigt_param,rad_vel,rv_cut_a,rv_cut_b,spec_i,order_i,bjd)

    return fitGauss_param,e_fitGauss_param,fitVoigt_param,e_fitVoigt_param


def activity_index(Flux, crval, crpix, cdelt, rad_vel, bjd, trasmittance_file, index_id, plot):
    """ Calculate the S index on CaHK and Halpha lines """
    try:
        # The trasmittance is used to compute the activity indices
        trasmittance_spline = UnivariateSpline(trasmittance_file[:,0],trasmittance_file[:,1],k=3,s=0.0)
    except:
        wavelength_coverage = sci.arange(3782, 6912, 1.)
        trasmittance_spline = UnivariateSpline(wavelength_coverage, sci.ones(len(wavelength_coverage)),k=1,s=0.0)
        print ' ** Unable to load transmittance file **'

    if index_id == 'CaHK':
        pix_i, pix_f = 3891.07, 4011.07

    if index_id == 'Halpha':
        pix_i, pix_f = 6545.495, 6584.684

    pix_I = int((pix_i*(1.+rad_vel/c)-crval+crpix*cdelt-cdelt)/cdelt)
    pix_F = int((pix_f*(1.+rad_vel/c)-crval+crpix*cdelt-cdelt)/cdelt)
    wave = sci.array([(pix_i+1 - crpix)*cdelt+crval for pix_i in xrange(pix_I,pix_F+1)])
    flux = Flux[pix_I:pix_F+1]/trasmittance_spline(wave)

    # 1d spectra are berv corrected
    wave = wave/(1.+rad_vel/c)

    if index_id == 'CaHK':
        V_band  = sci.searchsorted(wave,sci.array([3891.07,3911.07]))
        R_band  = sci.searchsorted(wave,sci.array([3991.07,4011.07]))

    if index_id == 'Halpha':
        V_band = sci.searchsorted(wave,sci.array([6550.87-10.75*0.5,6550.87+10.75*0.5]))#Da Silva+2011
        R_band = sci.searchsorted(wave,sci.array([6580.31-8.75*0.5,6580.31+8.75*0.5])) #Da Silva+2011
        C_band = sci.searchsorted(wave,sci.array([6562.808-0.8,6562.808+0.8]))#Da Silva+2011

    # if SNR < 4-5 (per pixel) the background correction is not reliable and we discard the measure
    avg_flux_VR_aux = sci.array(flux[V_band[0]:V_band[1]])
    avg_flux_VR_aux = sci.append(avg_flux_VR_aux, flux[R_band[0]:R_band[1]])
    avg_flux_VR = sci.average(avg_flux_VR_aux)

    if avg_flux_VR > 16:
        if index_id == 'CaHK':            
            f_V_Tr, f_R_Tr = flux[V_band[0]:V_band[1]], flux[R_band[0]:R_band[1]]
            f_VR = sci.sum(f_V_Tr)+sci.sum(f_R_Tr)

            wave_V, wave_R = wave[V_band[0]:V_band[1]],wave[R_band[0]:R_band[1]]
            Ca_K_band_wavelength = sci.array([3000,3933.663-1.09,3933.663,3933.663+1.09,8000])
            Ca_H_band_wavelength = sci.array([3000,3968.469-1.09,3968.469,3968.469+1.09,8000])
            Ca_HK_band_transmission = sci.array([0.,0.,1.,0.,0.])
            L_interpolation_K = UnivariateSpline(Ca_K_band_wavelength,Ca_HK_band_transmission,k=1,s=0.0)
            L_interpolation_H = UnivariateSpline(Ca_H_band_wavelength,Ca_HK_band_transmission,k=1,s=0.0)
            
            f_H, f_K = flux*L_interpolation_H(wave), flux*L_interpolation_K(wave)
            f_HK = sci.sum(f_H)+sci.sum(f_K)

            index = 20./1.09*f_HK/f_VR
            index = 1.05261895571*index+0.0262079553233

            if plot:
                pl.figure(1)
                pl.title(' BJD='+str(round(bjd-245e4,3))+', S='+str(round(index,3)))
                pl.plot(wave[V_band[0]:V_band[1]],(flux/trasmittance_spline(wave))[V_band[0]:V_band[1]],'k')
                pl.plot(wave,L_interpolation_K(wave)*flux/trasmittance_spline(wave),'k')
                pl.plot(wave,L_interpolation_H(wave)*flux/trasmittance_spline(wave),'k')
                pl.plot(wave[R_band[0]:R_band[1]],(flux/trasmittance_spline(wave))[R_band[0]:R_band[1]],'k')
                #pl.plot(wave,flux/trasmittance_spline(wave),'k')
                #pl.plot(wave,flux/trasmittance_spline(wave),'k')
                pl.axvline(3891.07,linestyle='--',color='y')
                pl.axvline(3911.07,linestyle='--',color='y')
                pl.axvline(3933.663,linestyle='--',color='y')
                pl.axvline(3968.469,linestyle='--',color='y')
                pl.axvline(3991.07,linestyle='--',color='y')
                pl.axvline(4011.07,linestyle='--',color='y')
                pl.xlim(3880, 4020)
                pl.show()

        if index_id == 'Halpha':
            H_V = sci.sum((flux/trasmittance_spline(wave))[V_band[0]:V_band[1]])
            H_R = sci.sum((flux/trasmittance_spline(wave))[R_band[0]:R_band[1]])
            H_C = sci.sum((flux/trasmittance_spline(wave))[C_band[0]:C_band[1]])
            index = H_C/(H_R + H_V)

            if plot:
                pl.title(' BJD='+str(round(bjd-245e4,3))+',H='+str(round(index,4)))
                pl.plot(wave,flux,'k')
                pl.axvline(6545.495,linestyle='--',color='y')
                pl.axvline(6556.245,linestyle='--',color='y')
                pl.axvline(6575.934,linestyle='--',color='y')
                pl.axvline(6584.684,linestyle='--',color='y')
                pl.axvline(6562.808-0.6786/2.,linestyle='--',color='y')
                pl.axvline(6562.808+0.6786/2.,linestyle='--',color='y')
                pl.xlim(6540, 6590)
                pl.show()
    else:
        index = 99

    return index


def template_process_plot(spec_i, order_i, bjd, trim, wave, flux, template, sigma_tmpl, sigma_ro, telluric):
    pl.ion()
    pl.figure(0,figsize=(14,8))
    pl.clf()
    pl.suptitle('Spectrum: '+str(spec_i+1)+'; BJD-2400000: '+str(round(bjd-2400000.,5))+'; Order: '+str(order_i))
    gs = GridSpec(4,5,height_ratios=[1,1,1,1],hspace=0.001,wspace=0.001)

    plot1 = pl.subplot(gs[-1,-1])
    O_C = ((flux-template)/sci.sqrt(template+sigma_ro**2)).real
    bins_width = 3.5*sci.std(O_C[trim:-trim])/(len(O_C[trim:-trim])**(1./3))  #Scott's normal reference rule
    n, bins, patches = pl.hist(O_C[trim:-trim],bins=sci.arange(-10,10,bins_width),orientation='horizontal',histtype='step',align='left',edgecolor='black',linewidth=2)
    bins = bins[:-1]
    fitGauss_param = hist_param(O_C,-10,10,bins_width)
    pl.plot(Gauss(bins,fitGauss_param[0],fitGauss_param[1],fitGauss_param[2],fitGauss_param[3]),bins,'r')
    xticklabels = plot1.get_xticklabels()
    pl.setp(xticklabels, visible=False)
    pl.ylim(-10,10)

    plot2 = pl.subplot(gs[0,:-1])
    pl.plot(wave[trim:-trim],template[trim:-trim],'k')
    #pl.errorbar(wave[trim:-trim],template[trim:-trim],yerr=sigma_tmpl[trim:-trim],color='k',marker='',linestyle='-')
    ylim_1, y_lim_2 = pl.yticks()[0][0],pl.yticks()[0][-1]
    pl.ylabel('Med Templ')

    plot3 = pl.subplot(gs[1,:-1])
    pl.plot(wave[trim:-trim],flux[trim:-trim],'k')
    pl.ylim(ylim_1,y_lim_2)
    pl.ylabel('Spec')

    plot4 = pl.subplot(gs[2,:-1])
    pl.plot(wave[trim:-trim],telluric[trim:-trim],'k')
    pl.yticks(sci.arange(-0.4, 1.5, 0.2))
    pl.ylim(0.5,1.5)
    pl.ylabel('Tellur')

    plot5 = pl.subplot(gs[3,:-1])
    pl.plot(wave[trim:-trim],O_C[trim:-trim],'k')
    pl.yticks(sci.arange(-9, 10, 3))
    pl.ylim(-10,10)
    pl.ylabel('$(O-E)/ \sigma$')
    pl.xlabel('Wavelength $[\AA]$')

    xticklabels = plot2.get_xticklabels()+plot3.get_xticklabels()+plot3.get_xticklabels()+plot4.get_xticklabels()
    pl.setp(xticklabels, visible=False)
    pl.draw()


def plot_rv_process(spec, spec_i, rad_vel_min, rad_vel_max, rad_vel, rad_vel_1, rv_i, chi2_rv, chi2_aux, chi2_oversampled, wave_aux, bins_width, iteration):
    chi2_aux_square = chi2_aux**2

    if iteration == 0:
        if len(chi2_rv) > 2:
            if chi2_rv[-1]/chi2_rv[-2] < 0.2:
                pl.ioff()
            else:
                pl.ion()
        else:
            pl.ion()

    if iteration == 1:
        if round(rad_vel_1,1) == round(rv_i,1):
            pl.ioff()
        else:
            pl.ion()

    pl.figure(0,figsize=(14,8))
    pl.clf()
    pl.suptitle('Spectrum: '+str(spec_i+1)+'    BJD: '+str(round(spec.bjd(spec_i)-2450000.,4))+'    $[(O-C)/\sigma]_{max}$ = '+str(round((chi2_aux).max(),1))+'    RV [km/s] = '+str('%.4f' % round(rv_i,4))+r'    $\chi^2_\nu$ = '+str(('%.4f' % round(chi2_rv[-1],4))))
    gs1 = GridSpec(3,2,bottom=0.55,top=0.9,hspace=0.0)
    gs2 = GridSpec(2,1,bottom=0.1,top=0.48,hspace=0.0)

    plot1 = pl.subplot(gs1[:,0])
    pl.plot(rad_vel,chi2_rv,'k.')
    pl.ylabel(r'$\chi^2_\nu$')
    pl.xlabel('RV [km/s]')
    plot1.ticklabel_format(style='sci',scilimits=(0,0),axis='y')
    if rv_i >= rad_vel_1-1.*plate_scale and chi2_rv[-1] < chi2_oversampled and iteration == 1:
        pl.xlim(rad_vel_1-1.*plate_scale,rad_vel_1+1.*plate_scale)
        pl.ylim(0.5, round(chi2_oversampled,1))
    else:
        pl.xlim(rad_vel_min,rad_vel_max)

    plot2 = pl.subplot(gs1[:-1,1])
    plot2.ticklabel_format(style='sci',scilimits=(0,0),axis='y')
    n, bins, patches = pl.hist(chi2_aux,bins=sci.arange(-40,20,bins_width),histtype='step',align='left',edgecolor='black',linewidth=2)
    bins = bins[:-1]
    fitGauss_param = hist_param(chi2_aux,-10, 10, bins_width)

    fit_gauss_hist = Gauss(bins,fitGauss_param[0],fitGauss_param[1],fitGauss_param[2],fitGauss_param[3])
    pl.plot(bins,fit_gauss_hist,'r')

    pl.ylabel('N')
    pl.xlim(-10,10)

    plot3 = pl.subplot(gs1[-1,1])
    pl.plot(bins,n-fit_gauss_hist,'k.')
    pl.axhline(0,color='k',linestyle='--')
    pl.ylim(-200,200)
    pl.yticks(sci.arange(-200,200,100))
    pl.xlim(-10,10)
    pl.setp(plot2.get_xticklabels(), visible=False)
    pl.ylabel('N-Gfit')
    pl.xlabel('(O-C)/$\sigma$')


    plot4 = pl.subplot(gs2[:,0])
    pl.plot(wave_aux,chi2_aux, marker='o', markersize=1, color='k', linestyle='')

    pl.ylabel('$(O-C)/\sigma$')
    if iteration == 0:
        pl.ylim(-100,100)
        pl.yticks(sci.arange(-80,81,20))
    if iteration == 1:
        pl.ylim(-40,40)
        #pl.yticks(sci.arange(-30,31,10))

    """
    plot5 = pl.subplot(gs2[1,0])

    pl.step(wave_aux,chi2_aux,'k')
    if iteration == 0:
        pl.ylim(-40,40)
        pl.yticks(sci.arange(-30,40,10))
    if iteration == 1:
        pl.ylim(-10,10)
        pl.yticks(sci.arange(-7.5,10,2.5))

    pl.xlabel('Wavelength [$\AA$]')
    pl.ylabel('$(O-C)/\sigma$')
    pl.setp(plot4.get_xticklabels(), visible=False)
    """
    if iteration == 0:
        #if round(spec.vrad_avrg(),0) == round(rv_i,0)-1:
        if len(chi2_rv) > 2:
            if chi2_rv[-1]/chi2_rv[-2] < 0.2:
                pl.show()
            else:
                pl.draw()
        else:
            pl.draw()

    if iteration == 1:
        if round(rad_vel_1,1) == round(rv_i,1):
            pl.show()
        else:
            pl.draw()


def plot_correl(correl, fitGauss_param, fitVoigt_param, rad_vel, rv_cut_a, rv_cut_b, spec_i, order_i, bjd):
    correl_spline = UnivariateSpline(rad_vel,correl,k=3,s=0.0)
    RV_oversampled = sci.arange(rad_vel[0],rad_vel[-1],(rad_vel[1]-rad_vel[0])/10.)
    correl_spl_eval = correl_spline(RV_oversampled)

    pl.ioff()
    pl.figure(0,figsize=(14,8))
    pl.clf()
    pl.title('Spectrum: '+str(spec_i)+'    BJD: '+str(round(bjd-2450000.,4))+'    RV = '+str(round(fitGauss_param[1],5))+' [km/s]')
    pl.plot(rad_vel,correl,'k.')



    pl.plot(rad_vel[rv_cut_a:rv_cut_b],correl[rv_cut_a:rv_cut_b],'r.')
    pl.plot(rad_vel[rv_cut_a:rv_cut_b],Gauss(rad_vel[rv_cut_a:rv_cut_b],fitGauss_param[0],fitGauss_param[1],fitGauss_param[2],fitGauss_param[3]),'r')
    if fitVoigt_param[0] != 99:
        pl.plot(rad_vel,Voigt(rad_vel,fitVoigt_param[0],fitVoigt_param[1],fitVoigt_param[2],fitVoigt_param[3],fitVoigt_param[4]),'b')

    pl.plot(fitGauss_param[1],fitGauss_param[0]+fitGauss_param[3],color='k',marker='+',markersize=15,markeredgewidth=1,linestyle='')
    pl.xlim(rad_vel[0],rad_vel[-1])
    pl.ylabel(r'$\chi^2$')
    pl.xlabel(r'$RV\ [km\,s^{-1}]$')
    pl.show()





spectra_list = glob(data_dir+'*_e2ds_A.fits')
N_spectra = len(spectra_list)
print ' * Loading',N_spectra,'e2ds_A files in',data_dir,'...'

if tmpl_ans == 'y' and not skip_bjd_tmpl_ans:
    try:
        create_master(data_dir,spectra_list,tmpl_ans, telluric_file)
        print ' * Template created!'
    except:
        print ' * Error :-('



if rv_ans and N_proc == 1:
    get_RV(data_dir, spectra_list, rv_ini, rv_end, rv_step, neglect_orders, dopp_slope, sig_clip, tmpl_ans, skip_bjd_tmpl_ans, rad_vel1_ans, telluric_file, stitching, N_spectra, N_spectra)


if rv_ans and N_proc > 1:
    if len(special_bjd) > 0 or len(special_bjd_interval) > 0:
        spec = Spec(data_dir,spectra_list)
        spec.load_spec(tmpl_ans,rv_data_ans,special_bjd,special_bjd_interval,neglect_bjd, rv_avg, rv_avg_val)
        spectra_list = spec.e2ds_list()
        N_spectra = spec.n_spectra()

    if N_spectra <= N_proc:
        N_proc = N_spectra

    if N_spectra > 0:
        sub_proc, n_split = [], int(N_spectra/N_proc)
        for proc_i in xrange(n_split,N_spectra+n_split,n_split):
            sub_proc.append(Process(target=get_RV, args=(data_dir,spectra_list,rv_ini,rv_end,rv_step,neglect_orders,dopp_slope,sig_clip,tmpl_ans,skip_bjd_tmpl_ans,rad_vel1_ans,telluric_file,stitching,proc_i,n_split)))
            sub_proc[-1].start()
            if proc_i/n_split == N_proc or proc_i >= N_spectra:
                for subproc_i in sub_proc:
                    subproc_i.join()
                sub_proc = []
    else:
        print ' * No spectra selected'

    if save_ans and N_spectra > 0:
        bjd, vrad, svrad_final, S_ind, Halpha, fwhm_ccf, contrast_ccf, bis_span_ccf, bis_span_chi2, ebis_span_chi2, vrad_8, evrad_8, vrad_6_8, evrad_6_8, vrad_4_6, evrad_4_6, vrad_2_4, evrad_2_4, vrad_2, evrad_2, sn10, sn50, sn60, seeing, airmass, svrad_bouchy, svrad_chi2, svrad_GFit, vradVoigt, berv, Chi2Min, FWHM, skew, total_pix_supr, valid_pix_supr, trim_pix_supr, telluric_pix_supr, outliers_pix_supr = sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([]), sci.array([])

        for proc_i in xrange(n_split,len(spectra_list)+n_split,n_split):
            bjd_aux, vrad_aux, svrad_final_aux, S_ind_aux, Halpha_aux, fwhm_ccf_aux, contrast_ccf_aux, bis_span_ccf_aux, bis_span_chi2_aux, ebis_span_chi2_aux, vrad_8_aux, evrad_8_aux, vrad_6_8_aux, evrad_6_8_aux, vrad_4_6_aux, evrad_4_6_aux, vrad_2_4_aux, evrad_2_4_aux, vrad_2_aux, evrad_2_aux, sn10_aux, sn50_aux, sn60_aux, seeing_aux, airmass_aux, svrad_bouchy_aux, svrad_chi2_aux, svrad_GFit_aux, vradVoigt_aux, berv_aux, Chi2Min_aux, FWHM_aux, skew_aux, total_pix_supr_aux, valid_pix_supr_aux, trim_pix_supr_aux, telluric_pix_supr_aux, outliers_pix_supr_aux = sci.loadtxt(data_dir+savename+'_NAIRA_v1_'+str(proc_i/n_split)+'.rdb', skiprows=2, unpack=True)

            try:
                for line_i in xrange(len(bjd_aux)):
                    if len(bjd) > 0:
                        pos_toIns = sci.searchsorted(bjd,bjd_aux[line_i])
                    else:
                        pos_toIns = 0

                    bjd = sci.insert(bjd, pos_toIns, bjd_aux[line_i])
                    vrad = sci.insert(vrad, pos_toIns, vrad_aux[line_i])
                    svrad_final = sci.insert(svrad_final, pos_toIns, svrad_final_aux[line_i])
                    S_ind = sci.insert(S_ind, pos_toIns, S_ind_aux[line_i])
                    Halpha = sci.insert(Halpha, pos_toIns, Halpha_aux[line_i])
                    fwhm_ccf = sci.insert(fwhm_ccf, pos_toIns, fwhm_ccf_aux[line_i])
                    contrast_ccf = sci.insert(contrast_ccf, pos_toIns, contrast_ccf_aux[line_i])
                    bis_span_ccf = sci.insert(bis_span_ccf, pos_toIns, bis_span_ccf_aux[line_i])
                    bis_span_chi2 = sci.insert(bis_span_chi2, pos_toIns, bis_span_chi2_aux[line_i])
                    ebis_span_chi2 = sci.insert(ebis_span_chi2, pos_toIns, ebis_span_chi2_aux[line_i])
                    vrad_8 = sci.insert(vrad_8, pos_toIns, vrad_8_aux[line_i])
                    evrad_8 = sci.insert(evrad_8, pos_toIns, evrad_8_aux[line_i])
                    vrad_6_8 = sci.insert(vrad_6_8, pos_toIns, vrad_6_8_aux[line_i])
                    evrad_6_8 = sci.insert(evrad_6_8, pos_toIns, evrad_6_8_aux[line_i])
                    vrad_4_6 = sci.insert(vrad_4_6, pos_toIns, vrad_4_6_aux[line_i])
                    evrad_4_6 = sci.insert(evrad_4_6, pos_toIns, evrad_4_6_aux[line_i])
                    vrad_2_4 = sci.insert(vrad_2_4, pos_toIns, vrad_2_4_aux[line_i])
                    evrad_2_4 = sci.insert(evrad_2_4, pos_toIns, evrad_2_4_aux[line_i])
                    vrad_2 = sci.insert(vrad_2, pos_toIns, vrad_2_aux[line_i])
                    evrad_2 = sci.insert(evrad_2, pos_toIns, evrad_2_aux[line_i])
                    sn10 = sci.insert(sn10, pos_toIns, sn10_aux[line_i])
                    sn50 = sci.insert(sn50, pos_toIns, sn50_aux[line_i])
                    sn60 = sci.insert(sn60, pos_toIns, sn60_aux[line_i])
                    seeing = sci.insert(seeing, pos_toIns, seeing_aux[line_i])
                    airmass = sci.insert(airmass, pos_toIns, airmass_aux[line_i])
                    svrad_bouchy = sci.insert(svrad_bouchy, pos_toIns, svrad_bouchy_aux[line_i])
                    svrad_chi2 = sci.insert(svrad_chi2, pos_toIns, svrad_chi2_aux[line_i])
                    svrad_GFit = sci.insert(svrad_GFit, pos_toIns, svrad_GFit_aux[line_i])
                    vradVoigt = sci.insert(vradVoigt, pos_toIns, vradVoigt_aux[line_i])
                    berv = sci.insert(berv, pos_toIns, berv_aux[line_i])
                    Chi2Min = sci.insert(Chi2Min, pos_toIns, Chi2Min_aux[line_i])
                    FWHM = sci.insert(FWHM, pos_toIns, FWHM_aux[line_i])
                    skew = sci.insert(skew, pos_toIns, skew_aux[line_i])
                    total_pix_supr = sci.insert(total_pix_supr, pos_toIns, total_pix_supr_aux[line_i])
                    valid_pix_supr = sci.insert(valid_pix_supr, pos_toIns, valid_pix_supr_aux[line_i])
                    trim_pix_supr = sci.insert(trim_pix_supr, pos_toIns, trim_pix_supr_aux[line_i])
                    telluric_pix_supr = sci.insert(telluric_pix_supr, pos_toIns, telluric_pix_supr_aux[line_i])
                    outliers_pix_supr = sci.insert(outliers_pix_supr, pos_toIns, outliers_pix_supr_aux[line_i])

            except:
                if len(bjd) > 0:
                    pos_toIns = sci.searchsorted(bjd,bjd_aux)
                else:
                    pos_toIns = 0

                bjd = sci.insert(bjd, pos_toIns, bjd_aux)
                vrad = sci.insert(vrad, pos_toIns, vrad_aux)
                svrad_final = sci.insert(svrad_final, pos_toIns, svrad_final_aux)
                S_ind = sci.insert(S_ind, pos_toIns, S_ind_aux)
                Halpha = sci.insert(Halpha, pos_toIns, Halpha_aux)
                fwhm_ccf = sci.insert(fwhm_ccf, pos_toIns, fwhm_ccf_aux)
                contrast_ccf = sci.insert(contrast_ccf, pos_toIns, contrast_ccf_aux)
                bis_span_ccf = sci.insert(bis_span_ccf, pos_toIns, bis_span_ccf_aux)
                bis_span_chi2 = sci.insert(bis_span_chi2, pos_toIns, bis_span_chi2_aux)
                ebis_span_chi2 = sci.insert(ebis_span_chi2, pos_toIns, ebis_span_chi2_aux)
                vrad_8 = sci.insert(vrad_8, pos_toIns, vrad_8_aux)
                evrad_8 = sci.insert(evrad_8, pos_toIns, evrad_8_aux)
                vrad_6_8 = sci.insert(vrad_6_8, pos_toIns, vrad_6_8_aux)
                evrad_6_8 = sci.insert(evrad_6_8, pos_toIns, evrad_6_8_aux)
                vrad_4_6 = sci.insert(vrad_4_6, pos_toIns, vrad_4_6_aux)
                evrad_4_6 = sci.insert(evrad_4_6, pos_toIns, evrad_4_6_aux)
                vrad_2_4 = sci.insert(vrad_2_4, pos_toIns, vrad_2_4_aux)
                evrad_2_4 = sci.insert(evrad_2_4, pos_toIns, evrad_2_4_aux)
                vrad_2 = sci.insert(vrad_2, pos_toIns, vrad_2_aux)
                evrad_2 = sci.insert(evrad_2, pos_toIns, evrad_2_aux)
                sn10 = sci.insert(sn10, pos_toIns, sn10_aux)
                sn50 = sci.insert(sn50, pos_toIns, sn50_aux)
                sn60 = sci.insert(sn60, pos_toIns, sn60_aux)
                seeing = sci.insert(seeing, pos_toIns, seeing_aux)
                airmass = sci.insert(airmass, pos_toIns, airmass_aux)
                svrad_bouchy = sci.insert(svrad_bouchy, pos_toIns, svrad_bouchy_aux)
                svrad_chi2 = sci.insert(svrad_chi2, pos_toIns, svrad_chi2_aux)
                svrad_GFit = sci.insert(svrad_GFit, pos_toIns, svrad_GFit_aux)
                vradVoigt = sci.insert(vradVoigt, pos_toIns, vradVoigt_aux)
                berv = sci.insert(berv, pos_toIns, berv_aux)
                Chi2Min = sci.insert(Chi2Min, pos_toIns, Chi2Min_aux)
                FWHM = sci.insert(FWHM, pos_toIns, FWHM_aux)
                skew = sci.insert(skew, pos_toIns, skew_aux)
                total_pix_supr = sci.insert(total_pix_supr, pos_toIns, total_pix_supr_aux)
                valid_pix_supr = sci.insert(valid_pix_supr, pos_toIns, valid_pix_supr_aux)
                trim_pix_supr = sci.insert(trim_pix_supr, pos_toIns, trim_pix_supr_aux)
                telluric_pix_supr = sci.insert(telluric_pix_supr, pos_toIns, telluric_pix_supr_aux)
                outliers_pix_supr = sci.insert(outliers_pix_supr, pos_toIns, outliers_pix_supr_aux)


            os.system('rm '+data_dir+savename+'_NAIRA_v1_'+str(proc_i/n_split)+'.rdb')


        if instrument == 'ESO' or instrument == 'TNG':
            sn_a, sn_b, sn_c = 'sn10','sn50','sn60'
        if instrument == 'OHP':
            sn_a, sn_b, sn_c = 'sn4','sn27','sn32'

        # We sort on bjd and save
        to_file = open(data_dir+savename+'_w'+str(slope_width)+'_s'+str(dopp_slope)+'_c'+str(sig_clip)+'_'+'_NAIRA_v1.rdb','w')
        to_file.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % ('jdb','vrad','svrad','s_mw','Halpha','fwhm','contrast','bis_span','bis_chi2','ebis_chi2','vrad20%','evrad20%','vrad40-20%','evrad40-20%','vrad60-40%','evrad60-40%','vrad80-60%','evrad80-60%','vrad80%','evrad80%',sn_a, sn_b, sn_c,'seeing','airmass','svrad_bouchy','svrad_chi2','svrad_GFit','vrad_Voigt','berv','chi2_min','chi2_fwhm','Skew','%Supr_Total','%Supr_ValidPix','%Supr_Trim','%Supr_Telluric','%Supr_Outliers'))
        to_file.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % ('---','----','-----','----','------','----','--------','--------','--------','---------','-------','--------','----------','-----------','----------','-----------','----------','-----------','-------','--------','----','----','----','------','-------','------------','----------','----------','----------','----','--------','---------','----','-----------','--------------','----------','--------------','--------------'))

        for line_i in xrange(len(bjd)):
            to_file.write("%.6f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.3f\t%.3f\t%.3f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.5f\t%.1f\t%.1f\t%.1f\t%.1f\t%.1f\n" % (bjd[line_i], vrad[line_i], svrad_final[line_i], S_ind[line_i], Halpha[line_i], fwhm_ccf[line_i], contrast_ccf[line_i], bis_span_ccf[line_i], bis_span_chi2[line_i], ebis_span_chi2[line_i], vrad_8[line_i], evrad_8[line_i], vrad_6_8[line_i], evrad_6_8[line_i], vrad_4_6[line_i], evrad_4_6[line_i], vrad_2_4[line_i], evrad_2_4[line_i], vrad_2[line_i], evrad_2[line_i], sn10[line_i], sn50[line_i], sn60[line_i], seeing[line_i], airmass[line_i], svrad_bouchy[line_i], svrad_chi2[line_i], svrad_GFit[line_i], vradVoigt[line_i], berv[line_i], Chi2Min[line_i], FWHM[line_i], skew[line_i], total_pix_supr[line_i], valid_pix_supr[line_i], trim_pix_supr[line_i], telluric_pix_supr[line_i], outliers_pix_supr[line_i]))
        to_file.close()
        print ' *',len(bjd),'RVs saved for',target
